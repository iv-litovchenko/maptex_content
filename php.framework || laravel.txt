# -------------------------------------------------------------------
# Laravel
# -------------------------------------------------------------------

# -------------------------------------------------------------------
# Структура папок и файлов
# -------------------------------------------------------------------

- app/ контроллеры, модели, провайдеры
- config/ настройки
- routes/ маршруты
- database/ информация о базе
- storage/ картинки, файлы
- .env (не загружается в git) - глобальные настройки проекта
----- APP_KEY - открытый ключ
----- APP_DEBUG - режим работы отладчика (true | false)
-----

Точкой входа для всех запросов к приложению Laravel является public/index.php-файл.
Все запросы направляются в этот файл конфигурацией вашего веб-сервера (Apache/Nginx).

В index.php загружается:
1) сгенерированное Composer определение автозагрузчика,
2) затем извлекает экземпляр приложения Laravel из bootstrap/app.php.
3) Первое действие, предпринимаемое самим Laravel, — создание экземпляра контейнера приложения/службы.
4) Затем входящий запрос отправляется либо в ядро HTTP, либо в ядро консоли,
в зависимости от типа запроса, поступающего в приложение.
Эти два ядра служат центральным расположением, через которое проходят все запросы.
Ядро HTTP, которое находится в app/Http/Kernel.php.
5). Ядро HTTP расширяет Illuminate\Foundation\Http\Kernelкласс,
который определяет массив bootstrappers который будет запущен до выполнения запроса.
 Эти загрузчики настраивают обработку ошибок, настраивают ведение журнала, определяют
 среду приложения и выполняют другие задачи, которые необходимо выполнить до фактической обработки запроса.
6) Ядро HTTP также определяет список промежуточного программного обеспечения ,
через которое должны пройти все запросы, прежде чем они будут обработаны приложением.
Эти промежуточные программы обрабатывают чтение и запись сеанса HTTP , определяют,
находится ли приложение в режиме обслуживания, проверяют токен CSRF и многое другое.
7) Сигнатура метода для ядра HTTP handleметод довольно прост: он получает Requestи возвращает Response.
Думайте о ядре как о большом черном ящике, представляющем все ваше приложение.
Отправьте ему HTTP-запросы, и он вернет HTTP-ответы.
8) Одним из наиболее важных действий по начальной загрузке ядра является загрузка поставщиков услуг для вашего приложения.
Поставщики услуг несут ответственность за начальную загрузку всех различных компонентов платформы,
таких как база данных, очередь, компоненты проверки и маршрутизации.
Все поставщики услуг для приложения настроены в config/app.php файл конфигурации providers множество.
Laravel будет перебирать этот список провайдеров и создавать экземпляры каждого из них. После создания экземпляров поставщиков registerметод будет вызываться для всех провайдеров. Затем, когда все провайдеры зарегистрированы, bootметод будет вызываться для каждого провайдера. Это сделано для того, чтобы поставщики услуг могли зависеть от того, будет ли каждая привязка контейнера зарегистрирована и доступна к тому времени, когда их bootметод выполняется.
По сути, каждая основная функция, предлагаемая Laravel, загружается и настраивается поставщиком услуг. Поскольку они загружают и настраивают так много функций, предлагаемых фреймворком, поставщики услуг являются наиболее важным аспектом всего процесса начальной загрузки Laravel.
9) Одним из наиболее важных поставщиков услуг в вашем приложении является App\Providers\RouteServiceProvider.
Этот поставщик услуг загружает файлы маршрутов, содержащиеся в вашем приложении. routesкаталог.
Давай, взломай RouteServiceProviderкод и посмотрите, как это работает!

После загрузки приложения и регистрации всех поставщиков услуг Requestбудут переданы маршрутизатору для отправки.
Маршрутизатор отправит запрос на маршрут или контроллер, а также запустит любое промежуточное ПО для конкретного маршрута.
Промежуточное ПО предоставляет удобный механизм фильтрации или проверки HTTP-запросов, поступающих в ваше приложение.
Как только метод маршрута или контроллера вернет ответ, ответ будет отправлен обратно через
промежуточное программное обеспечение маршрута, давая приложению возможность изменить или проверить исходящий ответ.

Наконец, как только ответ возвращается через промежуточное ПО, ядро HTTP handleметод возвращает
объект ответа и index.php файл вызывает sendметод возвращаемого ответа. В sendметод отправляет содержимое ответа в веб-браузер пользователя.

Поставщики услуг действительно являются ключом к начальной загрузке приложения Laravel. Экземпляр приложения создается, поставщики услуг регистрируются, и запрос передается загруженному приложению. Это действительно так просто!

Четкое понимание того, как приложение Laravel создается и загружается через поставщиков услуг, очень ценно. Поставщики услуг вашего приложения по умолчанию хранятся в app/Providersкаталог.

По умолчанию AppServiceProviderдовольно пусто. Этот провайдер — отличное место для добавления собственных
загрузочных и сервисных привязок вашего приложения. Для больших приложений вы можете создать несколько поставщиков
услуг, каждый из которых будет выполнять более точную загрузку определенных служб, используемых вашим приложением.

# -------------------------------------------------------------------
# Сервисный контейнер (Service Container)
# -------------------------------------------------------------------

// Поскольку репозиторий внедряется, мы можем легко заменить его другой реализацией.
// Мы также можем легко «издеваться» или создавать фиктивную реализацию UserRepository при тестировании нашего приложения.

protected $users;
public function __construct(UserRepository $users){
    $this->users = $users;
}

// Автоматическое внедрение
// Нет необходимости привязывать классы к контейнеру, если они не зависят ни от каких интерфейсов.
// Контейнеру не нужно указывать, как создавать эти объекты, поскольку он может автоматически разрешать эти объекты с помощью отражения.
class Service { }
Route::get('/', function (Service $service) { }

Многие классы, которые вы будете писать при создании приложения Laravel,
автоматически получают свои зависимости через контейнер, включая
контроллеры, прослушиватели событий, промежуточное ПО и многое другое.
Кроме того, вы можете указывать зависимости в handle метод очереди заданий.

Итак, когда вам приходилось вручную взаимодействовать с контейнером?
Во-первых, если вы пишете класс, реализующий интерфейс, и хотите указать тип этого интерфейса в конструкторе маршрута или класса,
вы должны сообщить контейнеру, как разрешить этот интерфейс.
Во-вторых, если вы пишете пакет Laravel, которым планируете поделиться с другими разработчиками Laravel,
вам может потребоваться привязать службы вашего пакета к контейнеру.

>> Связывание
Почти все ваши привязки контейнера службы будут зарегистрированы в поставщиках услуг,
поэтому большинство этих примеров демонстрирует использование контейнера в этом контексте.

$service = new Transistor(new PodcastParser);
$this->app->instance(Transistor::class, $service);
$this->app->bind(Transistor::class, function ($app) {
$this->app->singleton(Transistor::class, function ($app) {
    return new Transistor($app->make(PodcastParser::class));
});

// Контекстная привязка
$this->app->when([VideoController::class, UploadController::class])->needs(Filesystem::class)->give(function () {
    return Storage::disk('s3');
});

->needs('$variableName')
->give($value);

// EventPusher интерфейс и RedisEventPusher реализация
$this->app->bind(EventPusher::class, RedisEventPusher::class);

// За пределами поставщика услуг
App::bind(Transistor::class, function ($app) { });

// Контейнерные события
// Контейнер службы запускает событие каждый раз, когда разрешает объект.
// Вы можете прослушать это событие с помощью resolvingметод:
$this->app->resolving(Transistor::class, function ($transistor, $app) { });

# -------------------------------------------------------------------
# Поставщики услуг (Service Providers)
# $ php artisan make:provider RiakServiceProvider
# -------------------------------------------------------------------

Поставщики услуг являются центральным местом для начальной загрузки всех приложений Laravel.
Ваше собственное приложение, а также все основные службы Laravel загружаются через поставщиков услуг.
Но что мы подразумеваем под «загрузкой»? В общем, мы имеем в виду регистрацию вещей, включая регистрацию привязок контейнеров служб,
прослушивателей событий, промежуточного программного обеспечения и даже маршрутов. Поставщики услуг являются центральным местом для настройки вашего приложения.

Если вы откроете config/app.phpфайл, включенный в Laravel, вы увидите providersмножество.
Это все классы поставщиков услуг, которые будут загружены для вашего приложения.
По умолчанию в этом массиве перечислены основные поставщики услуг Laravel.
 Эти провайдеры загружают основные компоненты Laravel, такие как почтовая программа, очередь, кеш и другие.
  Многие из этих провайдеров являются «отложенными» провайдерами, то есть они не будут загружаться при каждом запросе,
  а только тогда, когда предоставляемые ими услуги действительно необходимы.

Все поставщики услуг расширяют Illuminate\Support\ServiceProviderучебный класс.
Большинство поставщиков услуг содержат registerи bootметод. В рамках registerметод,
вы должны привязывать вещи только к сервис-контейнеру . Вы никогда не должны пытаться зарегистрировать какие-либо
прослушиватели событий, маршруты или любую другую функциональность в пределах registerметод.

Все поставщики услуг зарегистрированы в config/app.phpконфигурационный файл.
Этот файл содержит providersмассив, в котором вы можете перечислить имена классов ваших поставщиков услуг.
По умолчанию в этом массиве перечислены основные поставщики услуг Laravel. Э

Laravel компилирует и хранит список всех услуг, предоставляемых отложенными поставщиками услуг,
вместе с именем своего класса поставщиков услуг.
Затем, только когда вы пытаетесь разрешить одну из этих служб, Laravel загружает поставщика служб.

use Illuminate\Support\ServiceProvider;
use Illuminate\Contracts\Routing\ResponseFactory;
use Illuminate\Contracts\Support\DeferrableProvider;
class RiakServiceProvider extends ServiceProvider implements DeferrableProvider { // Отложенный провайдер
class RiakServiceProvider extends ServiceProvider {

    // Если ваш поставщик услуг регистрирует много простых привязок, вы можете использовать bindingsа
    // также singletonsсвойства вместо ручной регистрации каждой привязки контейнера.
    // Простые привязки
    public $bindings = [
        ServerProvider::class => DigitalOceanServerProvider::class,
    ];

    // Простые привязки
    public $singletons = [
        DowntimeNotifier::class => PingdomDowntimeNotifier::class,
        ServerProvider::class => ServerToolsProvider::class,
    ];

    // Как упоминалось ранее, в рамках registerметод, вы должны привязывать вещи только к сервис-контейнеру .
    // Вы никогда не должны пытаться зарегистрировать какие-либо прослушиватели событий, маршруты или любую
    // другую функциональность в пределах registerметод. В противном случае вы можете случайно воспользоваться услугой,
    // предоставляемой поставщиком услуг, который еще не загружен.
    // В рамках любого из методов вашего поставщика услуг у вас всегда есть доступ к $appсвойство, которое обеспечивает доступ к сервисному контейнеру:
    public function register(ResponseFactory $response)
    {
        $this->app->singleton(); //...
        $response->macro('serialized', function ($value) {});
    }

    // Итак, что, если нам нужно зарегистрировать компоновщик представлений в нашем сервис-провайдере?
    // Это должно быть сделано в течение bootметод. Этот метод вызывается после того, как все другие поставщики услуг
    // были зарегистрированы , что означает, что у вас есть доступ ко всем другим службам, которые были зарегистрированы фреймворком:
    public function boot()
    {
        View::composer('view', function () {});
    }
}

# -------------------------------------------------------------------
# Фасады (Facades) = Базовый класс
# В приложении Laravel фасад — это класс, который обеспечивает доступ
# к объекту из контейнера.
# Вместо этого Cacheфасад расширяет основание Facadeкласс и определяет
# метод getFacadeAccessor(). Задача этого метода — вернуть имя привязки
# сервисного контейнера. Когда пользователь ссылается на любой статический метод
# в Cacheфасад, Laravel разрешает cacheсвязывание из сервисного контейнера
# и запускает запрошенный метод (в данном случае get) против этого объекта.
# -------------------------------------------------------------------

В документации Laravel вы увидите примеры кода, который взаимодействует с функциями Laravel через «фасады».
Фасады предоставляют «статический» интерфейс для классов, доступных в сервис-контейнере .
Laravel поставляется со многими фасадами, которые обеспечивают доступ почти ко всем функциям Laravel.

Фасады Laravel служат «статическими прокси» для базовых классов в сервис-контейнере,
предоставляя преимущества лаконичного, выразительного синтаксиса, сохраняя при этом большую
тестируемость и гибкость, чем традиционные статические методы

Все фасады Laravel определены в Illuminate\Support\Facadesпространство имен.
Итак, мы можем легко получить доступ к фасаду следующим образом:

Route::get('/users', function () {
    return response()->json([
        // ...
    ]);
});


>> Когда использовать фасады
Поскольку фасады очень просты в использовании и не требуют внедрения,
можно легко позволить вашим классам продолжать расти и использовать
множество фасадов в одном классе. Используя внедрение зависимостей,
этот потенциал смягчается визуальной обратной связью, которую большой
 конструктор дает вам, что ваш класс становится слишком большим.
 Итак, при использовании фасадов обратите особое внимание на размер вашего класса,
 чтобы его сфера ответственности оставалась узкой.
 Если ваш класс становится слишком большим, подумайте о том, чтобы
 разделить его на несколько меньших классов.

Фасады Против. Внедрение зависимости

Одним из основных преимуществ внедрения зависимостей является возможность
 замены реализаций внедренного класса. Это полезно во время тестирования, поскольку вы можете внедрить макет или заглушку и утверждать,
 что для заглушки были вызваны различные методы.
Как правило, невозможно имитировать или заглушить действительно статический метод класса. Однако, поскольку фасады используют
 динамические методы для прокси-вызовов методов для объектов, разрешенных из сервисного контейнера,
мы фактически можем тестировать фасады так же, как мы тестировали бы внедренный
экземпляр класса.

Фасады Против. Вспомогательные функции
Между фасадами и вспомогательными функциями нет абсолютно никакой практической разницы.
При использовании вспомогательных функций вы по-прежнему можете тестировать их точно так же,
как и соответствующий фасад.
return Illuminate\Support\Facades\View::make('profile');
return view('profile');

Справочник по классам фасадов
Facade 	                Class 	                                        Service Container Binding
App 	                Illuminate\Foundation\Application 	            app
Artisan 	            Illuminate\Contracts\Console\Kernel 	        artisan
Auth 	                Illuminate\Auth\AuthManager 	                auth
Auth (Instance) 	    Illuminate\Contracts\Auth\Guard 	            auth.driver
Blade 	                Illuminate\View\Compilers\BladeCompiler 	    blade.compiler
Broadcast 	            Illuminate\Contracts\Broadcasting\Factory
Broadcast (Instance) 	Illuminate\Contracts\Broadcasting\Broadcaster
Bus 	                Illuminate\Contracts\Bus\Dispatcher
Cache 	                Illuminate\Cache\CacheManager 	                cache
Cache (Instance) 	    Illuminate\Cache\Repository 	                cache.store
Config 	                Illuminate\Config\Repository 	                config
Cookie 	                Illuminate\Cookie\CookieJar 	                cookie
Crypt 	                Illuminate\Encryption\Encrypter 	            encrypter
Date 	                Illuminate\Support\DateFactory 	                date
DB 	Illuminate\Database\DatabaseManager 	                            db
DB (Instance) 	        Illuminate\Database\Connection 	                db.connection
Event 	                Illuminate\Events\Dispatcher 	                events
File 	                Illuminate\Filesystem\Filesystem 	            files
Gate 	                Illuminate\Contracts\Auth\Access\Gate
Hash 	                Illuminate\Contracts\Hashing\Hasher 	        hash
Http 	                Illuminate\Http\Client\Factory
Lang 	                Illuminate\Translation\Translator 	            translator
Log 	                Illuminate\Log\LogManager 	                    log
Mail 	                Illuminate\Mail\Mailer 	                        mailer
Notification 	        Illuminate\Notifications\ChannelManager
Password 	            Illuminate\Auth\Passwords\PasswordBrokerManager auth.password
Password (Instance) 	Illuminate\Auth\Passwords\PasswordBroker 	    auth.password.broker
Queue 	                Illuminate\Queue\QueueManager 	                queue
Queue (Instance) 	    Illuminate\Contracts\Queue\Queue 	            queue.connection
Queue (Base Class) 	    Illuminate\Queue\Queue
Redirect 	            Illuminate\Routing\Redirector 	                redirect
Redis 	                Illuminate\Redis\RedisManager 	                redis
Redis (Instance) 	    Illuminate\Redis\Connections\Connection 	    redis.connection
Request 	            Illuminate\Http\Request 	                    request
Response 	            Illuminate\Contracts\Routing\ResponseFactory
Response (Instance) 	Illuminate\Http\Response
Route 	                Illuminate\Routing\Router 	                    router
Schema 	                Illuminate\Database\Schema\Builder
Session 	            Illuminate\Session\SessionManager 	            session
Session (Instance) 	    Illuminate\Session\Store 	                    session.store
Storage 	            Illuminate\Filesystem\FilesystemManager 	    filesystem
Storage (Instance) 	    Illuminate\Contracts\Filesystem\Filesystem  	filesystem.disk
URL 	                Illuminate\Routing\UrlGenerator 	            url
Validator 	            Illuminate\Validation\Factory 	                validator
Validator (Instance) 	Illuminate\Validation\Validator
View 	                Illuminate\View\Factory 	                    view
View (Instance)         Illuminate\View\View
Vite 	                Illuminate\Foundation\Vite

# -------------------------------------------------------------------
# | 1 | Маршрутизация (сопоставление запроса и обработчика)
# App\Providers\RouteServiceProvider
# routes/web.php
# routes/api.php (/api)
# $ php artisan route:list
# $ php artisan route:list -v
# $ php artisan route:list --path=api
# $ php artisan route:list --except-vendor
# $ php artisan route:list --only-vendor
# -------------------------------------------------------------------

// Самые простые маршруты Laravel принимают URI и замыкание
use Illuminate\Support\Facades\Route;

Route::view('/welcome', 'welcome', ['name' => 'Taylor']); // Вид (зарезервированные параметры: view, data, status, а также headers)
Route::middleware(['first', 'second'])->group(function () { }); // Группировка маршрутов
Route::controller(OrderController::class)->group(function () { }); // Группа маршрутов с одним и тем же контроллером
Route::domain('{account}.example.com')->group(function () { }); // Группировка маршрутов для поддоменов
Route::prefix('admin.')->group(function () { }); // Префиксы в именовании (->name());

Route::get('/greeting', function () { return 'Hello World'; });
Route::get('/user', [UserController::class, 'index']); // Контроллер
Route::get($uri, $callback)->name('profile');
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);

Route::match(['get', 'post'], '/', $callback);
Route::any('/', $callback); // отвечает на все HTTP-команды
Route::fallback('/', $callback); // маршрут, который будет выполняться, когда ни один другой маршрут не соответствует входящему запросу.

// Ограничения
// Если входящий запрос не соответствует ограничениям шаблона маршрута, будет возвращен HTTP-ответ 404.
// App\Providers\RouteServiceProvider public function boot() { Route::pattern('id', '[0-9]+'); }
Route::get('/user/{id}', function ($id) {})
->where('name', '[A-Za-z]+');
->where('id', '[0-9]+');
->where(['id' => '[0-9]+', 'name' => '[a-z]+']);
->whereNumber('id')->whereAlpha('name');
->whereAlphaNumeric('name');
->whereUuid('id');
->whereIn('category', ['movie', 'song', 'painting']);
->where('search', '.*'); // /search/{search}

// CSRF-защита
Помните, что любые HTML-формы, указывающие на POST, PUT, PATCH, или же DELETE
маршруты, определенные в webфайл маршрутов должен включать поле токена CSRF.
<form method="POST" action="/profile">

@method('PUT')
@csrf

</form>

Route::redirect('/here', '/there'); // 302
Route::redirect('/here', '/there', 301);
Route::permanentRedirect('/here', '/there');

Поскольку $userпеременная указана как тип App\Models\UserEloquent модель и имя переменной соответствует {user}
URI, Laravel автоматически внедрит экземпляр модели, идентификатор которого соответствует соответствующему
значению из URI запроса. Если соответствующий экземпляр модели не найден в базе данных, автоматически будет сгенерирован HTTP-ответ 404.
Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) { })->scopeBindings();
Route::get('/users/{user:id} || /posts/{post:slug}', function (User $user) { return $user->email; })->withTrashed(); // Автовнедрение моделей как тип App\Models\UserEloquent
Route::get('/users', function (Request $request) { }); // Автозависимости, которые вы хотите, чтобы сервисный контейнер Laravel автоматически вставлял
Route::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) { });
->missing(function (Request $request) {
    return Redirect::route('locations.index'); // Настройка поведения отсутствующей модели
});

// Enums Неявная привязка перечисления
use App\Enums\Category;
enum Category: string
{
    case Fruits = 'fruits';
    case People = 'people';
}
Route::get('/categories/{category}', function (Category $category) {
    return $category->value;
});

// Явная привязка
// Вы также можете явно указать, как параметры маршрута соответствуют моделям.
// Чтобы зарегистрировать явную привязку, используйте modelметод, чтобы указать класс для данного параметра.
// Вы должны определить свои явные привязки модели в начале bootметод вашего RouteServiceProviderучебный класс:
RouteServiceProvider
public function boot()
{
    Route::model('user', User::class); //...
    Route::bind('user', function ($value) {
        return User::where('name', $value)->firstOrFail();
    });
}

// Поскольку мы связали все {user}параметры к App\Models\Userмодели экземпляр этого класса будет внедрен в маршрут.
// Так, например, запрос на users/1будет вводить Userэкземпляр из базы данных с идентификатором 1.
Route::get('/users/{user}', function (User $user) { });

$route = Route::current(); // Illuminate\Routing\Route
$name = Route::currentRouteName(); // string
$action = Route::currentRouteAction(); // string

# -------------------------------------------------------------------
# | 2 | Middleware
# $ php artisan make:middleware EnsureTokenIsValid
# Из коробки webа также apiгруппы промежуточного ПО автоматически
# применяются к соответствующим routes/web.phpа
# также routes/api.phpфайлы по App\Providers\RouteServiceProvider
# -------------------------------------------------------------------

Промежуточное ПО предоставляет удобный механизм проверки и фильтрации HTTP-запросов, поступающих в ваше приложение.
Например, Laravel включает промежуточное ПО, которое проверяет подлинность пользователя вашего приложения.
Если пользователь не аутентифицирован, промежуточное ПО перенаправит пользователя на экран входа в ваше приложение.
Однако, если пользователь аутентифицирован, промежуточное ПО позволит продолжить запрос дальше в приложении.

В  структуру Laravel включено несколько промежуточных программ, включая промежуточное ПО для аутентификации
  и защиты от CSRF. Все эти промежуточные программы расположены в app/Http/Middlewareкаталог.

Лучше всего представить промежуточное ПО как серию «слоев», через которые должны пройти HTTP-запросы,
прежде чем они попадут в ваше приложение. Каждый уровень может проверить запрос и даже полностью отклонить его.

1) Глобальное ПО промежуточного слоя (указывается в $middleware в app/Http/Kernel.php)
2) Назначение ПО промежуточного слоя для маршрутов (указывается в $routeMiddleware в app/Http/Kernel.php)
3) Группы ($middlewareGroups)
4) Сортировка промежуточного ПО ($middlewarePriority)

Route::middleware([EnsureTokenIsValid::class])->group(function () {...
Route::withoutMiddleware([EnsureTokenIsValid::class])->group(function () {...
Route::get('/', function () {
    //
})->middleware(['first', 'second'])
->middleware(EnsureTokenIsValid::class)
->middleware('role:editor');

Обрезка и нормализация ввода
По умолчанию Laravel включает промежуточное ПО App\Http\Middleware\TrimStringsи App\Http\Middleware\ConvertEmptyStringsToNullв
глобальный стек промежуточного ПО вашего приложения. Это ПО промежуточного слоя перечислено в глобальном стеке ПО
промежуточного слоя по App\Http\Kernelклассам. Это промежуточное ПО автоматически обрезает все входящие строковые поля в запросе,
 а также преобразует любые пустые строковые поля в файлы null. Это позволяет вам не беспокоиться об этих проблемах нормализации
  в ваших маршрутах и ​​​​контроллерах.

Если вы хотите отключить это поведение для всех запросов, вы можете удалить два промежуточных ПО
 из стека промежуточного ПО вашего приложения, удалив их из $middlewareсвойства вашего App\Http\Kernelкласса.

App\Http\Middleware\TrustProxiesпромежуточное ПО, включенное в ваше приложение Laravel, которое позволяет вам быстро
настроить балансировщики нагрузки или прокси-серверы, которым должно доверять ваше приложение.
 Ваши доверенные прокси-серверы должны быть перечислены в виде массива в $proxies

Laravel включает cache.headersпромежуточное ПО, которое можно использовать для быстрой установки
Cache-Controlзаголовка для группы маршрутов. Директивы должны быть предоставлены с использованием
«змеиного случая», эквивалентного соответствующей директиве управления кэшем, и должны быть разделены точкой с запятой. Если etagуказан в списке директив, то в качестве идентификатора ETag будет автоматически установлен хеш MD5 содержимого ответа:
Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function () {});

Файлы cookie и шифрование
По умолчанию все файлы cookie, созданные Laravel, зашифрованы и подписаны,
поэтому клиент не может их изменить или прочитать. Если вы хотите отключить
шифрование для подмножества файлов cookie, созданных вашим приложением,
вы можете использовать $exceptсвойство App\Http\Middleware\EncryptCookiesпромежуточного
программного обеспечения, которое находится в app/Http/Middlewareкаталоге:

/**
 * The names of the cookies that should not be encrypted.
 *
 * @var array
 */
protected $except = [
    'cookie_name',
];

# -------------------------------------------------------------------
# | 3 | CSRF Protection
# -------------------------------------------------------------------

// В App\Http\Middleware\VerifyCsrfToken промежуточное ПО , которое входит в web
// $token = $request->session()->token();
Laravel автоматически генерирует «токен» CSRF для каждого активного пользовательского сеанса ,
управляемого приложением. Этот токен используется для проверки того, что аутентифицированный
пользователь действительно делает запросы к приложению. Поскольку этот токен хранится в сеансе
пользователя и меняется каждый раз при повторном создании сеанса,
вредоносное приложение не может получить к нему доступ.

Иногда вам может понадобиться исключить набор URI из защиты CSRF. Например, если вы используете Stripe
 для обработки платежей и используете их систему веб-перехватчиков, вам необходимо исключить маршрут
 обработчика веб-перехватчиков Stripe из защиты CSRF, поскольку Stripe не будет знать, какой токен CSRF отправлять на ваши маршруты.
Для удобства промежуточное ПО CSRF автоматически отключается для всех маршрутов при запуске тестов .

В дополнение к проверке токена CSRF в качестве параметра POST,
 App\Http\Middleware\VerifyCsrfTokenПО промежуточного слоя также проверит X-CSRF-TOKENзаголовок запроса. Вы можете, например, сохранить токен в HTML metaярлык:

$.ajaxSetup({
    headers: {
        'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
    }
});

X-XSRF-ТОКЕН

<meta name="csrf-token" content="{{ csrf_token() }}">

Laravel хранит текущий токен CSRF в зашифрованном XSRF-TOKENcookie, который включается в каждый ответ, созданный платформой.
 Вы можете использовать значение cookie для установки X-XSRF-TOKENзаголовок запроса.

Этот файл cookie в первую очередь отправляется для удобства разработчиков, поскольку некоторые фреймворки и библиотеки JavaScript,
 такие как Angular и Axios, автоматически помещают его значение в X-XSRF-TOKENзаголовок для запросов того же происхождения.

По умолчанию resources/js/bootstrap.jsфайл включает HTTP-библиотеку Axios, которая автоматически отправит X-XSRF-TOKENзаголовок для вас.

# -------------------------------------------------------------------
# | 4 | Controllers
# $ php artisan make:controller ProvisionServer --invokable // | 4 |
# $ php artisan make:controller PhotoController --resource // | 4 |
# $ php artisan make:controller PhotoController --model=Photo --resource
# -------------------------------------------------------------------

<?php
// Если действие контроллера особенно сложное,
// может оказаться удобным посвятить этому единственному действию целый класс контроллера.
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\User;

Route::get('/user/{id}', [UserController::class, 'show']);
Route::get('/user/{id}', UserController::class); // Одиночное действие
Route::resource('photos', PhotoController::class); // Ресурсные контроллеры (CRUD)
Route::resource('photos.comments', PhotoCommentController::class); // Вложенный ресурс (/photos/{photo}/comments/{comment})
Route::apiResource('photos', PhotoController::class); // Ресурсные контроллеры (Api)

Verb 	    URI 	                Action 	    Route Name
GET 	    /photos 	            index 	    photos.index
GET 	    /photos/create 	        create 	    photos.create
POST 	    /photos 	            store 	    photos.store
GET 	    /photos/{photo} 	    show 	    photos.show
GET 	    /photos/{photo}/edit 	edit 	    photos.edit
PUT/PATCH 	/photos/{photo} 	    update 	    photos.update
DELETE 	    /photos/{photo} 	    destroy 	photos.destroy

// Вложенные маршруты
Verb	    URI	                                Action	    Route Name
GET	        /photos/{photo}/comments	        index	    photos.comments.index
GET	        /photos/{photo}/comments/create	    create	    photos.comments.create
POST	    /photos/{photo}/comments	        store	    photos.comments.store
GET	        /comments/{comment}	                show	    comments.show
GET	        /comments/{comment}/edit	        edit	    comments.edit
PUT/PATCH	/comments/{comment}	                update	    comments.update
DELETE	    /comments/{comment}	                destroy	    comments.destroy

// А) Внедрение зависимости через конструктор
// Б) Внедрение зависимости через метод

class UserController extends Controller
{
    /**
     * The user repository instance.
     */
    protected $users;

    /**
     * Instantiate a new controller instance.
     *
     * @param  \App\Repositories\UserRepository  $users
     * @return void
     */
    public function __construct(UserRepository $users))
    {
        $this->users = $users;
        $this->middleware('auth');
        $this->middleware('log')->only('index');
        $this->middleware('subscribed')->except('store');
        $this->middleware(function ($request, $next) {
            return $next($request);
        });
    }

    /**
     * Provision a new web server.
     * @param  \Illuminate\Http\Request  $request
     * @param  string  $id
     * @return \Illuminate\Http\Response
     */
    public function __invoke(Request $request, $id)
    {
        $name = $request->name;
        return view('user.profile', [
            'user' => User::findOrFail($id)
        ]);
    }
}

# -------------------------------------------------------------------
# | 6 | HTTP Requests (запросы)
# -------------------------------------------------------------------

Класс Laravel Illuminate\Http\Requestпредоставляет объектно-ориентированный способ взаимодействия с текущим HTTP-запросом,
обрабатываемым вашим приложением, а также извлекает входные данные, файлы cookie и файлы, которые были отправлены вместе с запросом.

// Illuminate\Http\Request;
$value = $request->header('X-Header-Name', 'default');
$name = $request->input('name');
if ($request->hasHeader('X-Header-Name')) {
if ($request->isMethod('post')) {
if ($request->is('admin/*')) {
if ($request->routeIs('admin.*')) {
$url = $request->url();
$uri = $request->path();
$urlWithQueryString = $request->fullUrl(); // ->fullUrlWithQuery(['type' => 'phone']);
$request->host();
$request->httpHost();
$request->schemeAndHttpHost();
$ipAddress = $request->ip();
$method = $request->method();
$token = $request->bearerToken(); // Для удобства этот bearerTokenметод можно использовать для извлечения
маркера носителя из Authorizationзаголовка. Если такого заголовка нет, будет возвращена пустая строка:

$contentTypes = $request->getAcceptableContentTypes();
if ($request->accepts(['text/html', 'application/json'])) {

// Получение ввода
$value = $request->cookie('name');
$input = $request->input();
$input = $request->all();
$input = $request->collect();
$request->collect('users')->each(function ($user) {
$name = $request->input('name', 'Sally');
$name = $request->input('products.0.name');
$names = $request->input('products.*.name');

// Получение входных данных из строки запроса
$name = $request->query('name');
$name = $request->query('name', 'Helen');
$query = $request->query();
$name = $request->string('name')->trim(); // <input type="text"> <textarea> // Получение строковых входных значений
$archived = $request->boolean('archived'); // <input type="checkbox"> // Получение логических входных значений
$birthday = $request->date('birthday', '!H:i', 'Europe/Madrid'); // Получение входных значений даты
$status = $request->enum('status', \App\Enums\Status\Status::class); // Получение входных значений Enum

// Получение части входных данных
$input = $request->only(['username', 'password']);
$input = $request->only('username', 'password');
$input = $request->except(['credit_card']);
$input = $request->except('credit_card');

if ($request->has('name')) { // определить, присутствует ли значение в запросе
if ($request->has(['name', 'email'])) { //
if ($request->hasAny(['name', 'email'])) { // присутствует какое-либо из указанных значений
if ($request->missing('name')) { // отсутствует ли данный ключ в запросе
if ($request->filled('name')) { // присутствует ли значение в запросе и не является ли оно пустым
$request->whenFilled('name', function ($input) {
$request->whenHas('name', function ($input) {
    // The "name" value is present...
}, function () {
    // The "name" value is not present...
});

$request->merge(['votes' => 0]);
$request->mergeIfMissing(['votes' => 0]);

// Старый ввод
Laravel позволяет вам сохранять ввод из одного запроса во время следующего запроса.
Эта функция особенно полезна для повторного заполнения форм после обнаружения ошибок проверки.
Однако, если вы используете включенные в Laravel функции проверки , возможно, вам не потребуется вручную использовать эти методы перепрошивки входных данных сеанса напрямую, поскольку некоторые из встроенных средств проверки Laravel будут вызывать их автоматически.

Метод flashкласса Illuminate\Http\Requestбудет отображать текущий ввод в сеанс ,
чтобы он был доступен во время следующего запроса пользователя к приложению:
$request->flash();
$request->flashOnly(['username', 'email']);
$request->flashExcept('password');
return redirect('form')->withInput();
return redirect()->route('user.create')->withInput();
return redirect('form')->withInput(
    $request->except('password')
);

$username = $request->old('username'); // Чтобы получить флэш-вход из предыдущего запроса
<input type="text" name="username" value="{{ old('username') }}">

// Получение загруженных файлов
$file = $request->file('photo');
if ($request->hasFile('photo')) {
if ($request->file('photo')->isValid()) { // убедиться в отсутствии проблем с загрузкой файла
$path = $request->photo->path();
$extension = $request->photo->extension();

Для хранения загруженного файла вы обычно используете одну из настроенных вами файловых систем .
У UploadedFileкласса есть storeметод, который перемещает загруженный файл на один из ваших дисков,
который может быть расположен в вашей локальной файловой системе или в облачном хранилище, таком как Amazon S3.

$path = $request->photo->store('images');
$path = $request->photo->store('images', 's3');
$path = $request->photo->storeAs('images', 'filename.jpg'); // Если вы не хотите, чтобы имя файла генерировалось автоматически
$path = $request->photo->storeAs('images', 'filename.jpg', 's3'); // Если вы не хотите, чтобы имя файла генерировалось автоматически

# -------------------------------------------------------------------
# | 7 | HTTP Responses (ответы)
# Создание ответов
# -------------------------------------------------------------------

Все маршруты и контроллеры должны возвращать ответ для отправки обратно в браузер пользователя.
Laravel предоставляет несколько различных способов возврата ответов.
Самый простой ответ — это возврат строки из маршрута или контроллера.

// Можете возвращать коллекции Eloquent из своих маршрутов или контроллеров? Они будут автоматически преобразованы в JSON.
Cookie::queue('name', 'value', $minutes); // Если вы хотите убедиться, что файл cookie отправляется вместе с исходящим ответом, но у вас еще нет экземпляра этого ответа, вы можете использовать Cookieфасад для «постановки в очередь» файлов cookie
Cookie::expire('name'); // сли у вас еще нет экземпляра исходящего ответа, вы можете использовать метод Cookieфасада expireдля истечения срока действия файла cookie
$cookie = cookie('name', 'value', $minutes);


Route::get('/', function () {
    return 'Hello World';
    return [1, 2, 3]; // Фреймворк автоматически преобразует массив в ответ JSON
    return $user; // Преобразует модели и коллекции в ответы JSON, соблюдая скрытые атрибуты модели
    return response('Hello World', 200)
                    ->withoutCookie('name') // удалить куки, истечив срок их действия
                    ->cookie($cookie)
                    ->cookie( // Прикрепление файлов cookie к ответам
                        'name', 'value', $minutes, $path, $domain, $secure, $httpOnly
                    )
                    ->header('Content-Type', 'text/plain' // метод для добавления ряда заголовков к ответу перед отправкой обратно пользователю:
                    ->withHeaders([
                        'Content-Type' => $type,
                        'X-Header-One' => 'Header Value',
                        'X-Header-Two' => 'Header Value',
                    ]);

    // Поскольку эта функция использует сеанс , убедитесь, что маршрут, вызывающий backфункцию, использует группу web
    return redirect('home/dashboard');
    return back()->withInput(); // перенаправить пользователя в его предыдущее местоположение, например, когда отправленная форма недействительна.
    return redirect()->route('login');
    return redirect()->route('profile', ['id' => 1]); // /profile/{id}
    return redirect()->route('profile', [$user]); // /profile/{id}
    return redirect()->action([UserController::class, 'index']);
    return redirect()->action([UserController::class, 'profile'], ['id' => 1]);
    return redirect()->away('https://www.google.com');

    // Перенаправление с использованием Flashed Session Data
    @if (session('status'))
        <div class="alert alert-success">
            {{ session('status') }}
        </div>
    @endif
    return redirect('dashboard')->with('status', 'Profile updated!');

    // Загрузка файлов
    return response()->download($pathToFile);
    return response()->download($pathToFile, $name, $headers);
    return response()->streamDownload(function () {
        echo GitHub::api('repo')
                    ->contents()
                    ->readme('laravel', 'laravel')['contents'];
    }, 'laravel-readme.md');

    // для отображения файла, такого как изображение или PDF, непосредственно в браузере пользователя, вместо того, чтобы инициировать загрузку
    return response()->file($pathToFile);
    return response()->file($pathToFile, $headers);

 });

// Макросы (если вы хотите определить пользовательский ответ, который вы можете повторно
// использовать в различных ваших маршрутах и ​​​​контроллерах)
return response()->caps('foo');
class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        Response::macro('caps', function ($value) {
            return Response::make(strtoupper($value));
        });
    }
}

# -------------------------------------------------------------------
# | 8 | Views
# $ php artisan make:component Alert // app/View/Components, resources/views/components
# $ php artisan make:component Forms/Input // в подкаталоге
# $ php artisan make:component forms.input --view // анонимный компонент без класса // <x-forms.input />
# $ php artisan make:component Alert --inline
# -------------------------------------------------------------------
use Illuminate\Support\Facades\View;
use Illuminate\Support\Facades\Blade;
Route::get('/', function () {
    return view('admin.profile', $data)->with('name', 'Victoria')->with('occupation', 'Astronaut');
    return view('greeting', ['name' => 'James']);
    return View::make('greeting', ['name' => 'James']);
    return View::first(['custom.admin', 'admin'], $data);
    if (View::exists('emails.customer')) { }

    return Blade::render(
        'Hello, {{ $name }}',
        ['name' => 'Julian Bashir'],
        deleteCachedView: true
    );
});

resources/views/admin/profile.blade.php
<html>
    <body>
        <!-- Комментарии -->
        {{-- This comment will not be present in the rendered HTML --}}

        <!-- Эхо -операторы Blade {{ }} автоматически отправляются через htmlspecialcharsфункцию PHP для предотвращения XSS-атак. -->
        <h1>Hello, {{ $name }} <?php echo $name; ?>.</h1>

        <!-- Вы можете поместить любой PHP-код внутрь оператора Blade echo: -->
        The current UNIX timestamp is {{ time() }}.

        <-- Если вы не хотите, чтобы ваши данные были экранированы, вы можете использовать следующий синтаксис:  -->
        Hello, {!! $name !!}.

        <!-- Blade и JavaScript-фреймворки -->
        Hello, @{{ name }}.
        @@if()
        @if()
        <script>
            var app = {{ Js::from($array) }};
        </script>
        @verbatim
            <div class="container">
                Hello, {{ name }}.
            </div>
        @endverbatim

        <!-- Директивы -->
        @if (count($records) === 1)
        @elseif (count($records) > 1)
        @else
        @endif

        @unless (Auth::check()) ... @endunless // You are not signed in.
        @isset($records) ... @endisset
        @empty($records) ... @endempty
        @auth('admin') ...  @endauth // The user is authenticated...
        @guest('admin') ... @endguest // The user is not authenticated...
        @production ... @endproduction // Production specific content...
        @env(['staging', 'production']) ... @endenv  // The application is running in "staging" or "production"...

        @hasSection('navigation')
            <div class="pull-right">
                @yield('navigation')
            </div>
        @endif
        @sectionMissing('navigation')
            <div class="pull-right">
                @include('default-navigation')
            </div>
        @endif

        @switch($i)
            @case(1) First case... @break
            @case(2) Second case... @break
            @default Default case...
        @endswitch

        @for ($i = 0; $i < 10; $i++)  The current value is {{ $i }} @endfor
        @foreach ($users as $user)  <p>This is user {{ $user->id }}</p>
            @continue($user->type == 1)
            @break($user->number == 5)
            $loop->index	Индекс текущей итерации цикла (начинается с 0).
            $loop->iteration	Текущая итерация цикла (начинается с 1).
            $loop->remaining	Итерации, оставшиеся в цикле.
            $loop->count	Общее количество элементов в итерируемом массиве.
            $loop->first	Является ли это первой итерацией цикла.
            $loop->last	Является ли это последней итерацией цикла.
            $loop->even	Является ли это четной итерацией цикла.
            $loop->odd	Является ли это нечетной итерацией цикла.
            $loop->depth	Уровень вложенности текущего цикла.
            $loop->parent	Во вложенном цикле переменная родительского цикла.
            @if ($loop->first)
            @if ($loop->last)
            @if ($loop->parent->first)
        @endforeach
        @forelse ($users as $user)
            <li>{{ $user->name }}</li>
        @empty
            <p>No users</p>
        @endforelse

        @while (true)
            <p>I'm looping forever.</p>
        @endwhile

        // Условные классы
        @php // Сырой PHP
            $isActive = false;
            $hasError = true;
        @endphp
        <span @class([
            'p-4',
            'font-bold' => $isActive,
            'text-gray-500' => ! $isActive,
            'bg-red' => $hasError,
        ])></span>
        <span class="p-4 text-gray-500 bg-red"></span>

        // Дополнительные атрибуты
        <button type="submit" @disabled($errors->isNotEmpty()) @readonly($user->isNotAdmin())  @required($user->isAdmin())>Submit</button>
        <input type="checkbox" name="active" value="active" @checked(old('active', $user->active)) />
        <select name="version">
            @foreach ($product->versions as $version)
                <option value="{{ $version }}" @selected(old('version') == $version)>
                    {{ $version }}
                </option>
            @endforeach
        </select>

        // Включение подвидов
        @include('shared.errors')
        @include('view.name', ['status' => 'complete'])
        @includeIf('view.name', ['status' => 'complete'])
        @includeWhen($boolean, 'view.name', ['status' => 'complete'])
        @includeUnless($boolean, 'view.name', ['status' => 'complete'])
        @includeFirst(['custom.admin', 'admin'], ['status' => 'complete'])
        @each('view.name', $jobs, 'job')
        @each('view.name', $jobs, 'job', 'view.empty')

        @once
            @push('scripts')
                <script>
                    // Your custom JavaScript...
                </script>
            @endpush
        @endonce
        @pushOnce('scripts')
            <script>
                // Your custom JavaScript...
            </script>
        @endPushOnce

        // Составные части (Components: компоненты и слоты)
        // Существует два подхода к написанию компонентов: компоненты на основе классов и анонимные компоненты.
        use Illuminate\Support\Facades\Blade;
        /**
         * Bootstrap your package's services.
         */
        public function boot()
        {
            // <x-inputs.button/> // вложенность
            // <x-alert type="error" :message="$message"/> // передача параметров
            Blade::anonymousComponentNamespace('flights.bookings.components', 'flights'); // <x-flights::panel :flight="$flight" />
            Blade::component('package-alert', Alert::class); // <x-package-alert/>
            Blade::componentNamespace('Nightshade\\Views\\Components', 'nightshade'); // <x-nightshade::calendar />
                                                                                         <x-nightshade::color-picker />
        }

    </body>
</html>

// Иногда может потребоваться обмен данными со всеми представлениями, отображаемыми вашим приложением.
<?php
namespace App\Providers;
use Illuminate\Support\Facades\View;
class AppServiceProvider extends ServiceProvider
class ViewServiceProvider extends ServiceProvider
{
    public function boot()
    {
        View::share('key', 'value');

        // Теперь, когда мы зарегистрировали композитор, composeметод App\View\Composers\ProfileComposer
        // класса будет выполняться каждый раз при profileрендеринге представления.
        // Давайте посмотрим на пример класса композитора:
        View::composer('profile', ProfileComposer::class); // app/View/Composers
        View::composer('*', function ($view) {});
        View::composer(['profile', 'dashboard'], function ($view) {
            //
        });

        // Представления «создатели» очень похожи на представления составителей;
        // однако они выполняются сразу после создания экземпляра представления, а не ждут, пока представление будет готово к рендерингу.
        // View::creator('profile', ProfileCreator::class);

        // Пользовательские директивы
        // <?php echo ($var)->format('m/d/Y H:i'); ?>
        Blade::directive('datetime', function ($expression) {
            return "<?php echo ($expression)->format('m/d/Y H:i'); ?>";
        });

        // Cost: {{ $money }}
        Blade::stringable(function (Money $money) {
            return $money->formatTo('en_GB');
        });

        // Пользовательские операторы If
        Blade::if('disk', function ($value) {
            return config('filesystems.default') === $value;
        });
        @disk('local')
            <!-- The application is using the local disk... -->
        @elsedisk('s3')
            <!-- The application is using the s3 disk... -->
        @else
            <!-- The application is using some other disk... -->
        @enddisk

        @unlessdisk('local')
            <!-- The application is not using the local disk... -->
        @enddisk
    }
}

По умолчанию представления шаблонов Blade компилируются по запросу.
Когда выполняется запрос, отображающий представление, Laravel определяет,
существует ли скомпилированная версия представления.

// Компоненты

<?php

namespace App\View\Components;
use Illuminate\View\Component;
use App\Services\AlertCreator;
class Alert extends Component
{
    // @aware директива не может получить доступ к родительским данным, которые не переданы явно родительскому компоненту
    // через атрибуты HTML. По умолчанию @props значения, которые не переданы явно родительскому компоненту,
    // не могут быть доступны @aware директива.

    // <x-dynamic-component :component="$componentName" class="mt-4" />
    // /resources/views/components/accordion.blade.php
    // /resources/views/components/accordion/item.blade.php
    <x-accordion>
        <x-accordion.item>
            ...
        </x-accordion.item>
    </x-accordion>

    // <x-alert alert-type="danger" />
    // <x-button ::class="{ danger: isDeleting }">
    // <button :class="{ danger: isDeleting }">
    // <div class="alert alert-{{ $type }}" {{ $attributes }}
    // <div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}>
    // <div {{ $attributes->class(['p-4', 'bg-red' => $hasError]) }}>
    // <div {{ $attributes->merge(['data-controller' => $attributes->prepends('profile-controller')]) }}>
    // <button {{ $attributes->class(['p-4'])->merge(['type' => 'button']) }}>
    // <button {{ $attributes->merge(['type' => 'button']) }}>
    // {{ $attributes->filter(fn ($value, $key) => $key == 'foo') }}
    // {{ $attributes->whereStartsWith('wire:model') }}
    // {{ $attributes->whereStartsWith('wire:model') }}
    // {{ $attributes->whereDoesntStartWith('wire:model') }}
    // {{ $attributes->whereStartsWith('wire:model')->first() }}
    // @if ($attributes->has('class'))
    // {{ $attributes->get('class') }}
    //    {{ $message }}
    //      Все атрибуты, не являющиеся частью конструктора компонента,
    //      будут автоматически добавлены в «набор атрибутов» компонента. {{ $attributes }}
    // </div>
    public $type;
    public $type2;
    public $message;
    protected $except = ['type2']; // Чтобы некоторые общедоступные методы или свойства не отображались как переменные в шаблоне компонента
    public function __construct(AlertCreator $creator, $type, $message, $alertType)
    {
        $this->creator = $creator; // Из сервис контейнера
        $this->type = $type;
        $this->message = $message;
        $this->alertType = $alertType;
    }
    public function render()
    {
        return view('components.alert');
        return function (array $data) {
            // $data['componentName'];
            // $data['attributes'];
            // $data['slot'];
            return '<div>Components content</div>';
        };
        return <<<'blade'
            <div class="alert alert-danger">
                {{ $slot }}
            </div>
        blade;
    }
    // Выполнить этот метод из своего шаблона компонента, вызвав переменную, соответствующую имени метода:
    // <option {{ $isSelected($value) ? 'selected="selected"' : '' }} value="{{ $value }}">
    //    {{ $label }}
    // </option>
    public function isSelected($option)
    {
        return $option === $this->selected;
    }
}

// Зарезервированные ключевые слова
По умолчанию некоторые ключевые слова зарезервированы для внутреннего использования Blade для визуализации компонентов.
Следующие ключевые слова не могут быть определены как общедоступные свойства или имена методов в ваших компонентах

* data
* render
* resolveView
* shouldRender
* view
* withAttributes
* withName

// Слоты
<!-- /resources/views/components/alert.blade.php -->
@props([
    'heading',
    'footer',
])
<div class="alert alert-danger">
    {{ $slot }}
</div>
<x-alert>
    <strong>Whoops!</strong> Something went wrong!
</x-alert>

// Макеты с использованием наследования шаблонов
<!-- resources/views/layouts/app.blade.php -->
<html>
    <head>
        <title>App Name - @yield('title', 'Default content') {{ $title ?? 'Todo Manager' }}</title>
    </head>
    <body>
        @section директива, определяет раздел содержимого,
        @yield директива используется для отображения содержимого данного раздела
        @section('sidebar')
            This is the master sidebar.
        @show
        <div class="container">
            @yield('content', 'Default content')
        </div>
    </body>
</html>

// Расширение макета
// @extends Директива Blade, чтобы указать, какой макет должен «наследовать» дочерний вид.
<!-- resources/views/child.blade.php -->
@extends('layouts.app')
@section('title', 'Page Title'
@section('sidebar')
    @parent
    <p>This is appended to the master sidebar.</p>
@endsection
@section('content')
    <p>This is my body content.</p>
@endsection

// В отличие от предыдущего примера, этот sidebar
// раздел заканчивается на @endsectionв место @show. @endsection
// директива будет определять только раздел, в то время как @showопределит и немедленно раздел.

// Формы
<form method="POST" action="/profile">
    @csrf
    @method('PUT')

    @error('title', 'email', 'login')
        <div class="alert alert-danger">{{ $message }}</div>
    @enderror
    <input id="email"
        type="email"
        class="@error('email') is-invalid @else is-valid @enderror">

    ...
</form>

// Сервисная инъекция
// В @inject Директива может использоваться для извлечения службы из контейнера служб .
// Первый аргумент передается @inject— это имя переменной, в которую будет помещена служба, а второй аргумент — это имя класса или интерфейса службы, которую вы хотите разрешить:
@inject('metrics', 'App\Services\MetricsService')

<div>
    Monthly Revenue: {{ $metrics->monthlyRevenue() }}.
</div>

# -------------------------------------------------------------------
# | 9 | Asset Bundling (Vite) - ранее webpack.mix
# Vite для объединения файлов CSS и JavaScript вашего приложения в готовые ресурсы
# file: vite.config.js
# file: .env (ASSET_URL=https://cdn.example.com)
# file: .env (VITE_SENTRY_DSN_PUBLIC=http://example.com)
# $ npm run dev
# $ npm run build
# -------------------------------------------------------------------

import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
import.meta.env.VITE_SENTRY_DSN_PUBLIC
import.meta.glob([
  '../images/**',
  '../fonts/**',
]);

export default defineConfig({
    server: {
        https: true,
        host: 'localhost',
    },
    plugins: [
        vue({
            template: {
                transformAssetUrls: {
                    base: null,
                    includeAbsolute: false,
                },
            },
        }),
        laravel([
            'resources/css/app.css',
            'resources/js/app.js',
        ]),
    ],
});

<!doctype html>
<head>
    {{-- ... --}}

    @vite(['resources/css/app.css', 'resources/js/app.js'])
    @vite('resources/js/app.js', 'vendor/courier/build')
</head>
<body>
<img src="{{ Vite::asset('resources/images/logo.png') }}">
</body>

// Отключение Vite в тестах
use Tests\TestCase;
class ExampleTest extends TestCase
{
    public function setUp(): void
    {
        parent::setUp();
        $this->withoutVite();
    }

    public function test_without_vite_example()
    {
        $this->withoutVite();
    }
}

# -------------------------------------------------------------------
# | 10 | Генерация ссылок (URL Generation)
# -------------------------------------------------------------------

use Illuminate\Support\Facades\URL;
$post = App\Models\Post::find(1);
echo url("/posts/{$post->id}");
echo URL::current();
echo url()->current();
echo url()->full(); // Get the current URL including the query string...
echo url()->previous();
echo route('post.show', ['post' => 1]);
echo route('comment.show', ['post' => 1, 'comment' => 3]);

$url = action([HomeController::class, 'index']);
$url = action([UserController::class, 'profile'], ['id' => 1]);

// Подписанные URL
return URL::signedRoute('unsubscribe', ['user' => 1]);
return URL::temporarySignedRoute(
    'unsubscribe', now()->addMinutes(30), ['user' => 1]
);
    // Проверка подписанных запросов маршрута
    if (! $request->hasValidSignature()) {
        abort(401);
    }
    if (! $request->hasValidSignatureWhileIgnoring(['page', 'order'])) {
        abort(401);
    }

    protected $routeMiddleware = [
        'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class,
    ];
    Route::post('/unsubscribe/{user}', function (Request $request) {
        // ...
    })->name('unsubscribe')->middleware('signed');

// Значения по умолчанию
<?php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Support\Facades\URL;
class SetDefaultLocaleForUrls
{
    public function handle($request, Closure $next)
    {
        URL::defaults(['locale' => $request->user()->locale]);

        return $next($request);
    }
}

# -------------------------------------------------------------------
# | 11 | HTTP Session
# config/session.php
# $ php artisan session:table // драйвер database
# $ php artisan migrate // драйвер database
# -------------------------------------------------------------------

Драйвера:
* file- сеансы хранятся в storage/framework/sessions.
* cookie- сеансы хранятся в безопасных, зашифрованных файлах cookie.
* database- сеансы хранятся в реляционной базе данных.
* memcached/ redis- сеансы хранятся в одном из этих быстрых хранилищ на основе кэша.
* dynamodb- сеансы хранятся в AWS DynamoDB.
* array- сеансы хранятся в массиве PHP и не сохраняются.

// Оба метода проверяются с помощью assertSessionHasметод, который доступен во всех ваших тестовых примерах.
$value = session('key');
$value = session('key', 'default');
session(['key' => 'value']);
$value = $request->session()->get('key');
$value = $request->session()->get('key', 'default');
$value = $request->session()->get('key', function () {
    return 'default';
});

$data = $request->session()->all();
if ($request->session()->has('users')) { }
if ($request->session()->exists('users')) { }
if ($request->session()->missing('users')) { }
$request->session()->put('key', 'value');
$request->session()->push('user.teams', 'developers'); // Отправка значений сеанса в массив
$value = $request->session()->pull('key', 'default'); // Получение и удаление элемента
$request->session()->increment('count');
$request->session()->increment('count', $incrementBy = 2);
$request->session()->decrement('count');
$request->session()->decrement('count', $decrementBy = 2);

// Флэш-данные
// После последующего HTTP-запроса прошитые данные будут удалены.
// Флэш-данные в первую очередь полезны для кратковременных сообщений о состоянии
$request->session()->flash('status', 'Task was successful!');
$request->session()->reflash();
$request->session()->keep(['username', 'email']);
$request->session()->now('status', 'Task was successful!'); // только для текущего запроса
$request->session()->forget('name');
$request->session()->forget(['name', 'status']);
$request->session()->flush();

// Повторное создание идентификатора сеанса
$request->session()->regenerate(); // вручную повторно сгенерировать идентификатор сеанса
$request->session()->invalidate(); // повторно сгенерировать идентификатор сеанса и удалить все данные из сеанса

# -------------------------------------------------------------------
# | 12 | Validation (валидация данных)
# $ php artisan make:request StorePostRequest // настраиваемые классы запросов, которые инкапсулируют собственную логику проверки и авторизации
# $ php artisan make:rule Uppercase --invokable
# protected $stopOnFirstFailure = true;
# protected $redirect = '/dashboard';
# protected $redirectRoute = 'dashboard';
# public function authorize()
  {
      $comment = Comment::find($this->route('comment'));
      return $comment && $this->user()->can('update', $comment);
  }
  protected function prepareForValidation()
  {
      $this->merge([
          'slug' => Str::slug($this->slug),
      ]);
  }
# -------------------------------------------------------------------

Laravel предлагает несколько разных подходов к проверке входящих данных вашего приложения.
Чаще всего используют validateметод, доступный для всех входящих HTTP-запросов.

Route::get('/post/create', [PostController::class, 'create']); // отобразит форму для пользователя
Route::post('/post', [PostController::class, 'store']); // сохранит новую запись блога в базе данных

Если правила проверки пройдены, ваш код продолжит нормально выполняться;
однако, если проверка не пройдена, Illuminate\Validation\ValidationException
будет выдано исключение, и правильный ответ об ошибке будет автоматически отправлен обратно пользователю.

Если проверка не пройдена во время традиционного HTTP-запроса, будет сгенерирован ответ перенаправления на предыдущий URL-адрес.
Если входящий запрос является запросом XHR, ответ JSON, содержащий сообщения об ошибках проверки будет возвращен

<?php

namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\Validator;
use Illuminate\Http\Request;
class PostController extends Controller
{
    public function create()
    {
        $title = $request->old('title'); // получить флэш-ввод из предыдущего запроса
        return view('post.create');
    }

    public function store(Request $request)
    {
        // Если проверка не пройдена, правильный ответ будет сгенерирован автоматически.
        // Если проверка пройдена, наш контроллер продолжит работу в обычном режиме
        // Все ошибки проверки и ввод запроса будут автоматически переданы в сеанс .
        // Во время запроса XHR, Laravel генерирует ответ JSON, содержащий все ошибки проверки . Этот ответ JSON будет отправлен с кодом состояния HTTP 422.
        // $errors переменная является общей для всех представлений вашего приложения Illuminate\View\Middleware\ShareErrorsFromSessionпромежуточное ПО
        $validatedData = $request->validateWithBag('post', [ // метод для проверки запроса и сохранения любых сообщений об ошибках в именованном пакете ошибок
        $validated = $request->validate([
            'title' => 'required|unique:posts|max:255',
            'title' => 'bail|required', // "bail" остановить выполнение правил проверки для атрибута после первой неудачной проверки
            'body' => 'required',
            'author.name' => 'required', // вложенные
            'author.description' => 'required',
            'publish_at' => 'nullable|date', // если вы не хотите, чтобы валидатор рассматривал nullзначения как недействительные
        ]);

        // Если проверка не пройдена, будет сгенерирован ответ перенаправления, чтобы отправить пользователя обратно в его предыдущее местоположени
        $validated = $request->validated();
        $validated = $request->safe()->only(['name', 'email']);
        $validated = $request->safe()->except(['name', 'email']);

        // Хук после проверки
        $validator->after(function ($validator) {
            if ($this->somethingElseIsInvalid()) {
                $validator->errors()->add(
                    'field', 'Something is wrong with this field!'
                );
            }
        });

        $validator->after(function ($validator) {
            if ($this->somethingElseIsInvalid()) {
                $validator->errors()->add('field', 'Something is wrong with this field!');
            }
        });

        $validator = Validator::make($request->all(), [
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ]);

        if ($validator->stopOnFirstFailure()->fails()) {
        if ($validator->fails()) {
            return redirect('post/create')
                        ->withErrors($validator)
                        ->withInput();
        }

        $validated = $validator->validated();
        return redirect('register')->withErrors($validator, 'login');  // Если на странице несколько форм

        $validated = $request->safe()->merge(['name' => 'Taylor Otwell']);
        $collection = $request->safe()->collect();
        $validated = $request->validated();
        $validated = $validator->validated();
        $validated = $request->safe()->only(['name', 'email']);
        $validated = $request->safe()->except(['name', 'email']);
        $validated = $request->safe()->all();

        $errors = $validator->errors();
        echo $errors->first('email');
        foreach ($errors->get('email') as $message) { }
        foreach ($errors->get('attachments.*') as $message) { }
        foreach ($errors->all() as $message) { }
        if ($errors->has('email')) { }
    }
}

<h1>Create Post</h1>

{{ $errors->login->first('email') }} // Если несколько форм на странице
@if ($errors->any())
    <div class="alert alert-danger">
        <ul>
            @foreach ($errors->all() as $error)
                <li>{{ $error }}</li>
            @endforeach
        </ul>
    </div>
@endif

@error('title')
    <div class="alert alert-danger">{{ $message }}</div>
@enderror

<input type="text" name="title" value="{{ old('title') }}">
<input ... class="@error('title', 'post') is-invalid @enderror">
<input id="title" type="text" name="title" class="@error('title') is-invalid @enderror">

# -------------------------------------------------------------------
# | 13 | Error Handling (Обработка ошибок)
# App\Exceptions\Handler
# .env (APP_DEBUG = true || false)
# abort(404); // сгенерировать исключение из любого места
# функция будет передана в представление как $exceptionпеременная
# <h2>{{ $exception->getMessage() }}</h2>
# php artisan vendor:publish --tag=laravel-errors
# resources/views/errors/4xx.blade.php
# resources/views/errors/5xx.blade.php
# -------------------------------------------------------------------

// За кулисами Laravel уже игнорирует некоторые типы ошибок, такие как исключения,
// возникающие из-за ошибок 404 HTTP «не найдено» или 419 ответов HTTP, сгенерированных недопустимыми токенами CSRF.

public function isValid($value)
{
    try {
        // Validate the value...
    } catch (Throwable $e) {
        report($e);

        return false;
    }
}


use App\Exceptions\InvalidOrderException;

class Handler extends ExceptionHandler
{
    protected $levels = [
        PDOException::class => LogLevel::CRITICAL,
    ];

    protected $dontReport = [
        InvalidOrderException::class,
    ];

    public function register()
    {
        $this->renderable(function (InvalidOrderException $e, $request) {
            return response()->view('errors.invalid-order', [], 500);
        });
        $this->renderable(function (NotFoundHttpException $e, $request) {
            if ($request->is('api/*')) {
                return response()->json([
                    'message' => 'Record not found.'
                ], 404);
            }
        });
    }
}

# -------------------------------------------------------------------
# | 14 | Logging (Логирование)
# config/logging.php
# -------------------------------------------------------------------

use Illuminate\Support\Facades\Log;
Log::channel('slack')->info('Something happened!'); // запись на определенные каналы
Log::stack(['single', 'slack'])->info('Something happened!');
Log::build(['driver' => 'single', 'path' => storage_path('logs/custom.log'),])->info('Something happened!');

Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);

    // config/logging.php

    return [
       ...
      'channels' => [
        'stack' => [
          'driver' => 'stack',
          'name' => 'channel-name',
          'channels' => ['single', 'slack'],
        ],

        'single' => [
          'driver' => 'single',
          'level' => 'debug',
        ],

        'slack' => [
          'driver' => 'slack',
          'url' => env('LOG_SLACK_WEBHOOK_URL'),
          'level' => 'critical',
        ],
        ...
    ];

# -------------------------------------------------------------------
# | 15 | Artisan Console (Консоль ремесленника )
# Artisan — это интерфейс командной строки, включенный в Laravel
# App\Console\Kernel.php // Регистрация команд
# config/tinker.php
# -------------------------------------------------------------------

$ php artisan list
$ php artisan help migrate
$ php artisan make:command SendEmails

$ php artisan tinker // позволяет вам взаимодействовать со всем вашим приложением Laravel в командной строке
$ php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"

protected $signature = 'mail:send {user}';
protected $signature = 'mail:send {user?}';
protected $signature = 'mail:send {user=foo}';
protected $signature = 'mail:send {user} {--queue}'; // опции ($php artisan mail:send 1 --queue)
protected $signature = 'mail:send {user} {--queue=}';

use App\Models\User;
use App\Support\DripEmailer;

Artisan::command('mail:send {user}', function (DripEmailer $drip, $user) {
    $drip->send(User::find($user));
})->purpose('Описание команды');

public function handle()
{
    $userId = $this->argument('user');
    $arguments = $this->arguments();

    $queueName = $this->option('queue');
    $options = $this->options();

    $name = $this->ask('What is your name?'); // запрос на ввод
    $password = $this->secret('What is the password?');
    if ($this->confirm('Do you wish to continue?')) { } // запрос подтверждения
    if ($this->confirm('Do you wish to continue?', true)) { }
    $name = $this->anticipate('What is your name?', ['Taylor', 'Dayle']); // Автозаполнение
    $name = $this->anticipate('What is your address?', function ($input) {
        // Return auto-completion options...
    });

    // Вопросы с несколькими вариантами ответов
    $name = $this->choice(
        'What is your name?',
        ['Taylor', 'Dayle'],
        $defaultIndex,
        $maxAttempts = null,
        $allowMultipleSelections = false
    );

    // Отправить вывод на консоль
    $this->info('The command was successful!');
    $this->error('Something went wrong!');
    $this->line('Display this on the screen');
    $this->newLine(3);
    $this->table(
        ['Name', 'Email'],
        User::all(['name', 'email'])->toArray()
    );

    // 1/3 [=========>------------------]  33%
    $users = $this->withProgressBar(User::all(), function ($user) {
        $this->performTask($user);
    });
    $bar = $this->output->createProgressBar(count($users));
    $bar->start();
    foreach ($users as $user) {
        $this->performTask($user);
        $bar->advance();
    }
    $bar->finish();

}

// Запуск команд
Artisan::call('mail:send 1 --queue=default');
Route::post('/user/{user}/mail', function ($user) {
    $exitCode = Artisan::call('mail:send', [
        'user' => $user, '--queue' => 'default'
    ]);
});

# -------------------------------------------------------------------
# | 16 | -
# -------------------------------------------------------------------

# -------------------------------------------------------------------
# | 17 | Cache (Кэш)
# config/cache.php
# Memcached , Redis , DynamoDB , File, Database ($php artisan cache:table)
# -------------------------------------------------------------------

Некоторые из задач извлечения или обработки данных, выполняемых вашим приложением, могут сильно нагружать ЦП
 или выполняться несколько секунд. В этом случае принято кэшировать полученные данные на время,
 чтобы их можно было быстро извлечь при последующих запросах тех же данных. Кэшированные данные обычно хранятся
 в очень быстром хранилище данных, таком как Memcached или Redis .

use Illuminate\Support\Facades\Cache;
$value = Cache::get('key');
$value = Cache::store('file')->get('foo');
Cache::store('redis')->put('bar', 'baz', 600); // 10 Minutes
$value = Cache::get('key');
$value = Cache::get('key', 'default');
$value = Cache::get('key', function () {
    return DB::table(/* ... */)->get();
});
if (Cache::has('key')) { }
Cache::increment('key');
Cache::increment('key', $amount);
Cache::decrement('key');
Cache::decrement('key', $amount);
$value = Cache::rememberForever('users', function () { // Извлечение элемента из кеша или сохранения его навсегда
$value = Cache::remember('users', $seconds, function () { // Получить и сохранить
    return DB::table('users')->get();
});
$value = Cache::pull('key'); // Получить и удалить

Cache::put('key', 'value', $seconds = 10);
Cache::put('key', 'value', now()->addMinutes(10));
Cache::add('key', 'value', $seconds); // добавит элемент в кеш только в том случае, если он еще не существует
Cache::forever('key', 'value');

// Удаление
Cache::forget('key');
Cache::put('key', 'value', 0);
Cache::put('key', 'value', -5);
Cache::flush();

// Тэги (не для всех драйверов)
Cache::tags(['people', 'artists'])->put('John', $john, $seconds);
Cache::tags(['people', 'authors'])->put('Anne', $anne, $seconds);
$john = Cache::tags(['people', 'artists'])->get('John');
$anne = Cache::tags(['people', 'authors'])->get('Anne');
Cache::tags(['people', 'authors'])->flush();
Cache::tags('authors')->flush();

// Блокировки
Cache::lock('foo', 10)->block(5, function () { //
$lock = Cache::lock('foo', 10);
if ($lock->get()) {
    // Lock acquired for 10 seconds...
    $lock->release();
}

use Illuminate\Contracts\Cache\LockTimeoutException;
$lock = Cache::lock('foo', 10);
try {
    $lock->block(5);
    // Lock acquired after waiting a maximum of 5 seconds...
} catch (LockTimeoutException $e) {
    // Unable to acquire lock...
} finally {
    optional($lock)->release();
}

$podcast = Podcast::find($id);
$lock = Cache::lock('processing', 120);
if ($lock->get()) {
    ProcessPodcast::dispatch($podcast, $lock->owner());
}
Cache::restoreLock('processing', $this->owner)->release();
Cache::lock('processing')->forceRelease();

# -------------------------------------------------------------------
# | 18 | Коллекции (В Illuminate\Support\Collectionclass)
# Предоставляет беглую удобную оболочку для работы с массивами данных.
# -------------------------------------------------------------------

use Illuminate\Support\Collection;
use Illuminate\Support\Str;

Collection::macro('toUpper', function () {
    return $this->map(function ($value) {
        return Str::upper($value);
    });
});
$collection = collect(['first', 'second']);
$upper = $collection->toUpper();

$collect = collect([1, 2, 3])->all(); // возвращает базовый массив, представленный коллекцией
$array = $collection->toArray();
$values = $collection->values();

$average = collect([1, 1, 2, 4])->avg(); // среднее значение
$sum = collect([1, 2, 3, 4, 5])->sum();

$chunks = $collection->chunk(4); // разбивает коллекцию на несколько меньших коллекций заданного размера
$collapsed = $collection->collapse(); // сворачивает коллекцию массивов в одну плоскую коллекцию
$collection->count();
$counted = $collection->countBy();
$sorted = $collection->sort();
$sorted = $collection->sortBy('title', SORT_NATURAL);

$first = collect([1, 2, 3, 4])->first();
$last = collect([1, 2, 3, 4])->last();
$collection->firstWhere('name', 'Linda');
$collection->forget('name'); // удалить
$value = $collection->get('name');
$collection->has('product');
$filtered = $collection->filter(function ($value, $key) {
    return $value > 2;
});

collect([])->isEmpty();
collect([])->isNotEmpty();
$person = $person->undot();

# -------------------------------------------------------------------
# | 19 | Контракты
# «Контракты» Laravel — это набор интерфейсов, которые определяют основные сервисы, предоставляемые фреймворком.
# Например, Illuminate\Contracts\Queue\Queueконтракт определяет методы, необходимые для постановки заданий в очередь
# Каждый контракт имеет соответствующую реализацию, предусмотренную фреймворком.
# -------------------------------------------------------------------

Laravel Фасады обеспечивают простой способ использования сервисов Laravel без необходимости указывать тип и разрешать контракты из сервисного контейнера.
В большинстве случаев на каждый фасад имеется эквивалентный контракт.

В отличие от фасадов, которые не требуют, чтобы вы требовали их
в конструкторе вашего класса, контракты позволяют вам определять явные зависимости для ваших классов.

# -------------------------------------------------------------------
# | 20 | Events (События)
# App\Providers\EventServiceProvider // Регистрация событий и слушателей
# app/Listeners
# app/Events
# $ php artisan event:list
# $ php artisan event:generate
# $ php artisan make:event PodcastProcessed
# $ php artisan make:listener SendPodcastNotification --event=PodcastProcessed
# $ php artisan event:cache
# $ php artisan event:clear
# -------------------------------------------------------------------

События Laravel обеспечивают простую реализацию шаблона наблюдателя,
позволяя вам подписываться и прослушивать различные события, происходящие в вашем приложении.

Классы событий обычно хранятся в app/Eventsкаталог,
в то время как их слушатели хранятся в app/Listeners.
одно событие может иметь несколько прослушивателей, которые не зависят друг от друга

protected $listen = [
    OrderShipped::class => [
        SendShipmentNotification::class,
    ],
];

// Обнаружение событий отключено по умолчанию, но вы можете включить его, переопределив shouldDiscoverEventsметод вашего приложения
public function shouldDiscoverEvents()
{
    return true;
}

public function boot()
{
    Event::listen('event.*', function ($eventName, array $data) {
    Event::listen(queueable(function (PodcastProcessed $event) {
    Event::listen(queueable(function (PodcastProcessed $event) {
        //
    })->onConnection('redis')->onQueue('podcasts')->delay(now()->addSeconds(10)));
}

Класс события — это, по сути, контейнер данных, который содержит информацию, связанную с событием.
Например, давайте предположим App\Events\OrderShipped

Прослушиватели событий получают экземпляры событий в свои handleметод.
В event:generateа также make:listener. Иногда вы можете захотеть остановить передачу события другим слушателям.
Вы можете сделать это, вернувшись falseот вашего слушателя handleметод.

Постановка слушателей в очередь может быть полезна, если ваш слушатель собирается выполнять медленную задачу,
такую ​​как отправка электронной почты или выполнение HTTP-запроса
Чтобы указать, что слушатель должен быть поставлен в очередь, добавьте ShouldQueueинтерфейс к классу слушателя.

Подписчики событий — это классы, которые могут подписываться на несколько событий из самого класса подписчика,
что позволяет определить несколько обработчиков событий в одном классе. Подписчики должны определить subscribe
метод, которому будет передан экземпляр диспетчера событий. Вы можете позвонить в listenметод
 в данном диспетчере для регистрации прослушивателей событий:

# -------------------------------------------------------------------
# | 21 | File Storage (Файловое хранилище)
# config/filesystems.php
# $ php artisan storage:link // Для создания символической ссылки
# -------------------------------------------------------------------

Laravel предоставляет мощную абстракцию файловой системы благодаря замечательному Flysystem от Франка де Йонге.
Интеграция Laravel Flysystem предоставляет простые драйверы для работы с локальными файловыми системами, SFTP и Amazon S3.
В publicдиск, включенный в ваше приложение filesystemsфайл конфигурации предназначен для файлов, которые будут общедоступными.
Чтобы сделать эти файлы доступными из Интернета, вы должны создать символическую ссылку из public/storageк storage/app/public.

Storage::disk('local')->put('example.txt', 'Contents'); // storage/app/example.txt
Storage::put('avatars/1', $content); // для сохранения аватара на диске по умолчанию
Storage::disk('s3')->put('avatars/1', $content); // Если ваше приложение взаимодействует с несколькими дисками
$contents = Storage::get('file.jpg');
if (Storage::disk('s3')->exists('file.jpg')) { } // определить, существует ли файл на диске
if (Storage::disk('s3')->missing('file.jpg')) { } // определить, отсутствует ли файл на диске:
return Storage::download('file.jpg', $name, $headers); // Загрузка файлов
$url = Storage::url('file.jpg'); // URL-адреса файлов
$url = Storage::temporaryUrl(
    'file.jpg', now()->addMinutes(5)
);

$size = Storage::size('file.jpg');
$time = Storage::lastModified('file.jpg');
$path = Storage::path('file.jpg');

Storage::put('file.jpg', $contents);
Storage::put('file.jpg', $resource);
if (! Storage::put('file.jpg', $contents)) { }

Storage::prepend('file.log', 'Prepended Text'); // писать в начало файла
Storage::append('file.log', 'Appended Text'); // писать в конец файла
Storage::copy('old/file.jpg', 'new/file.jpg');
Storage::move('old/file.jpg', 'new/file.jpg');

$path = Storage::putFile('photos', new File('/path/to/photo'));
$path = Storage::putFileAs('photos', new File('/path/to/photo'), 'photo.jpg');

echo asset('storage/file.txt'); // .env (ASSET_URL)
$url = asset('img/photo.jpg'); // http://example.com/assets/img/photo.jpg
$url = secure_asset('img/photo.jpg'); // https
$url = secure_url('user/profile');

$path = $request->file('avatar')->store('avatars');
$path = Storage::putFile('avatars', $request->file('avatar'));
$path = $request->file('avatar')->storeAs(
    'avatars', $request->user()->id
);
$path = $request->file('avatar')->store(
    'avatars/'.$request->user()->id, 's3'
);

$file = $request->file('avatar');
$name = $file->getClientOriginalName();
$extension = $file->getClientOriginalExtension();
$name = $file->hashName();
$extension = $file->extension();

Storage::delete('file.jpg');
Storage::delete(['file.jpg', 'file2.jpg']);
Storage::disk('s3')->delete('path/file.jpg');

$files = Storage::files($directory); // Получить все файлы в каталоге
$files = Storage::allFiles($directory); // включая все подкаталоги
$directories = Storage::directories($directory); // Получить все каталоги в каталоге
$directories = Storage::allDirectories($directory);
Storage::makeDirectory($directory); // Создать каталог
Storage::deleteDirectory($directory); // Удалить каталог

# -------------------------------------------------------------------
# | 22 | Helpers (Помощники)
# Laravel включает множество глобальных «вспомогательных» функций PHP.
# -------------------------------------------------------------------

$path = app_path('Http/Controllers/Controller.php');
$path = base_path('vendor/bin');
$path = config_path('app.php');
$path = database_path('factories/UserFactory.php');
$path = lang_path('en/messages.php');
$path = public_path('css/app.css');
$path = resource_path('sass/app.scss');
$path = storage_path('app/file.txt');
$path = mix('css/app.css');

echo __('messages.welcome');
$class = class_basename('Foo\Bar\Baz');
$converted = Str::camel('foo_bar'); // fooBar
$converted = Str::kebab('fooBar'); // foo-bar
$converted = Str::of('foo_bar')->camel(); // fooBar
$converted = Str::of('fooBar')->snake(); // foo_bar
$converted = Str::of('foo_bar')->studly(); // FooBar
$traits = class_uses_recursive(App\Models\User::class); // Функция возвращает все черты, используемые классом, включая черты, используемые всеми его родительскими классами
echo e('<html>foo</html>'); // htmlspecialchars()

$string = Str::mask('taylor@example.com', '*', 3); // tay***************
$string = Str::mask('taylor@example.com', '*', -15, 3);
$string = Str::of('/foo/bar/baz.jpg')->basename('.jpg');
$html = Str::of('**Laravel**')->inlineMarkdown();
$result = Str::of('foo bar')->match('/foo (.*)/');

abort(403);
abort(403, 'Unauthorized.', $headers);
abort_if(! Auth::user()->isAdmin(), 403);
abort_unless(Auth::user()->isAdmin(), 403);

$container = app(); // В appфункция возвращает сервисного контейнера экземпляр
$api = app('HelpSpot\API');
$user = auth()->user();
$user = auth('admin')->user();
return back($status = 302, $headers = [], $fallback = '/');

$value = config('app.timezone', $default);
$env = env('APP_ENV', 'production');

dispatch(new App\Jobs\SendEmails); // функция помещает данное задание Laravel очередь заданий
event(new UserRegistered($user)); // функция отправляет данное событие своим слушателям:
dd($value1, $value2, $value3, ...);
dump($value1, $value2, $value3, ...);
info('Some helpful information!');
logger('User has logged in.', ['id' => $user->id]);

# -------------------------------------------------------------------
# | 23 | HTTP-клиент (Guzzle)
# -------------------------------------------------------------------

use Illuminate\Support\Facades\Http;
$response = Http::get('http://example.com'); // можно использовать для проверки ответа
$response->body() : string;
$response->json($key = null) : array|mixed;
$response->object() : object;
$response->collect($key = null) : Illuminate\Support\Collection;
$response->status() : int;
$response->ok() : bool;
$response->successful() : bool;
$response->redirect(): bool;
$response->failed() : bool;
$response->serverError() : bool;
$response->clientError() : bool;
$response->header($header) : string;
$response->headers() : array;

return Http::get('http://example.com/users/1')['name']; // JSON
return Http::dd()->get('http://example.com');
$response = Http::asForm()->post('http://example.com/users', [ // application/x-www-form-urlencoded
$response = Http::get('http://example.com/users', [
$response = Http::post('http://example.com/users', [
    'name' => 'Steve',
    'role' => 'Network Administrator',
]);

$response = Http::withHeaders([
    'X-First' => 'foo',
    'X-Second' => 'bar'
])->post('http://example.com/users', [
    'name' => 'Taylor',
]);

# -------------------------------------------------------------------
# | 24 | Почта
# config/mail.php
# php artisan make:mail OrderShipped
# return $this->view('emails.orders.shipped');
# resources/views/emails
# -------------------------------------------------------------------

<?php

namespace App\Mail;

use App\Models\Order;
use Illuminate\Bus\Queueable;
use Illuminate\Mail\Mailable;
use Illuminate\Queue\SerializesModels;

class OrderShipped extends Mailable
{
    use Queueable, SerializesModels;

    protected $order;

    public function __construct(Order $order)
    {
        $this->order = $order;
    }

    public function build()
    {
        return $this->view('emails.orders.shipped')
                    ->tag('shipment')
                    ->metadata('order_id', $this->order->id);
                    ->attachFromStorageDisk('s3', '/path/to/file');
                    ->attachFromStorage('/path/to/file', 'name.pdf', [
                        'mime' => 'application/pdf'
                    ])
                    ->attach('/path/to/file')
                    ->attach('/path/to/file', [
                        'as' => 'name.pdf',
                        'mime' => 'application/pdf',
                    ])
                    ->with([
                        'orderName' => $this->order->name,
                        'orderPrice' => $this->order->price,
                    ]);
    }
}

<div>
    Price: {{ $orderPrice }}
    <img src="{{ $message->embed($pathToImage) }}">
</div>

Mail::to($request->user())->send(new OrderShipped($order));
Mail::to($request->user())
    ->cc($moreUsers)
    ->bcc($evenMoreUsers)
    ->send(new OrderShipped($order));

# -------------------------------------------------------------------
# | 25 | Уведомления
# php artisan make:notification InvoicePaid
# -------------------------------------------------------------------

Помимо поддержки отправки электронной почты , Laravel обеспечивает поддержку отправки уведомлений по различным каналам доставки,
включая электронную почту, SMS (через Vonage , ранее известное как Nexmo) и Slack .

Как правило, уведомления должны быть короткими информационными сообщениями, уведомляющими пользователей о том, что произошло в вашем приложении.
Например, если вы пишете приложение для выставления счетов, вы можете отправить своим пользователям уведомление «Счет оплачен»
по электронной почте и через SMS-каналы.

<?php
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable
{
    use Notifiable;
}

use App\Notifications\InvoicePaid;
use Illuminate\Support\Facades\Notification;
$user->notify(new InvoicePaid($invoice));
Notification::send($users, new InvoicePaid($invoice));
Notification::sendNow($developers, new DeploymentCompleted($deployment));
$delay = now()->addMinutes(10);
$user->notify((new InvoicePaid($invoice))->delay($delay));

# -------------------------------------------------------------------
# | 26 | Package Development
# $ php artisan vendor:publish
# $ php artisan vendor:publish --tag=public --force
# -------------------------------------------------------------------

use VendorPackage\View\Components\AlertComponent;
public function boot()
{
    Blade::component('package-alert', AlertComponent::class); // <x-package-alert/>
    Blade::componentNamespace('Nightshade\\Views\\Components', 'nightshade'); // <x-nightshade::calendar />
                                                                                 <x-nightshade::color-picker />
}

# -------------------------------------------------------------------
# | 27 | Queues (очереди)
# config/queue.php
# драйверы Amazon SQS, Redis, реляционная база данных, null (без добавления в очередь, выполняется сразу)
# $ php artisan make:job ProcessPodcast
# $ php artisan queue:monitor  // мониторинг ваших очередей
# $ php artisan queue:work --queue=high,default // запуск работника очереди
# $ php artisan queue:restart
# $ php artisan queue:failed // просмотреть все невыполненные задания, которые были вставлены в failed_jobsтаблицу базы данных
# $ php artisan queue:retry all // повторить все неудачные задания
# $ php artisan queue:flush // удалить все невыполненные задания
# $ php artisan queue:clear // удалить все задания из очереди
# Дравер Database (QUEUE_CONNECTION=database)
# $ php artisan queue:table
# $ php artisan queue:failed-table
# $ php artisan migrate // создать задание

// Чтобы процесс queue:work постоянно работал в фоновом режиме, вы должны использовать монитор процесса, такой как Supervisor,
// чтобы гарантировать, что рабочий процесс очереди не остановится.
# -------------------------------------------------------------------

При создании веб-приложения у вас могут возникнуть некоторые задачи, такие как синтаксический анализ и сохранение загруженного CSV-файла,
выполнение которых во время обычного веб-запроса занимает слишком много времени. К счастью, Laravel позволяет легко создавать задания в очереди,
которые могут выполняться в фоновом режиме.

use App\Jobs\ProcessPodcast;
ProcessPodcast::dispatch();

<?php

use App\Jobs\Middleware\RateLimited;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUnique; // может быть только 1 (уникальный) экземпляр определенного задания в очереди
use Illuminate\Contracts\Queue\ShouldBeUniqueUntilProcessing; // работа была разблокирована непосредственно перед ее обработкой
class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique, ShouldBeUniqueUntilProcessing
{
    public $backoff = 3; // солько секунд Laravel должен ждать перед повторной попыткой задания
    public $tries = 5;
    public $uniqueFor = 3600;
    public function uniqueId()
    {
        return $this->product->id;
    }
    public function middleware()
    {
        return [new RateLimited];
    }
    public function handle()
    {
        $this->release(); // вернуть задание в очередь, чтобы его можно было повторить позже
        $this->fail(); // сбой задания вручную
    }
}

// Отправка в очередь
$podcast = Podcast::create(/* ... */);
ProcessPodcast::dispatch($podcast);
ProcessPodcast::dispatch($podcast)->delay(now()->addMinutes(10)); // запустить через 10 минут
ProcessPodcast::dispatchSync($podcast); // немедленная отправка
ProcessPodcast::dispatch()->onQueue('emails'); // оптравка в очередь "emails"
Bus::chain([ // цепочка заданий
    new ProcessPodcast,
    new OptimizePodcast,
    function () {
        Podcast::update(/* ... */);
    },
])->catch(function (Throwable $e) {
    // A job within the chain has failed...
})->onConnection('redis')->onQueue('processing')->dispatch();

# -------------------------------------------------------------------
# | 28 | Task Scheduling (Планирование задач)
# app/Console/Kernel.php (Определение расписаний)
# $ php artisan schedule:list // просмотреть обзор ваших запланированных задач
# $ php artisan schedule:work // локальный запуск планировщика
# Запланированные задачи вашего приложения не будут выполняться, когда приложение находится в режиме обслуживания
# * * * * * cd /path-to-your-project && php artisan schedule:run >> /dev/null 2>&1
# -------------------------------------------------------------------

Планировщик команд Laravel предлагает новый подход к управлению запланированными задачами на вашем сервере.
Планировщик позволяет вам свободно и выразительно определять расписание команд в самом приложении Laravel.
При использовании планировщика на вашем сервере требуется только одна запись cron.

<?php
namespace App\Console;
use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;
use Illuminate\Support\Facades\DB;
class Kernel extends ConsoleKernel
{
    protected function schedule(Schedule $schedule)
    {
        $schedule->exec('node /home/forge/script.js')->daily();
        $schedule->command('emails:send Taylor --force')->daily();
        $schedule->command(SendEmailsCommand::class, ['Taylor', '--force'])->daily();
        $schedule->job(new Heartbeat, 'heartbeats', 'sqs')->everyFiveMinutes();
        $schedule->call(new DeleteRecentUsers)->daily(); // содержащие __invoke() метод
        $schedule->call(function () {
            DB::table('recent_users')->delete();
        })->daily();
        $schedule->command('foo')
                  ->weekdays() // параметры частоты расписания
                  ->hourly() // дополнительных ограничений расписания
                  ->timezone('America/Chicago')
                  ->between('8:00', '17:00');

        // будет запускаться каждую минуту, если она еще не запущена. withoutOverlapping
        $schedule->command('emails:send')->withoutOverlapping(); // предотвращение дублирования задач
        ->onOneServer();
        ->evenInMaintenanceMode(); // принудительно запустить задачу даже в режиме обслуживания
    }
}

# -------------------------------------------------------------------
# | 29 | Authentication (Аутентификация)
# config/auth.php
# По своей сути средства аутентификации Laravel состоят из «охранников» и «провайдеров».
# Охранники определяют, как пользователи аутентифицируются для каждого запроса. Например, Laravel поставляется с sessionGuard, который поддерживает состояние, используя хранилище сеансов и файлы cookie.
# Провайдеры определяют, как пользователи извлекаются из вашего постоянного хранилища. Laravel поставляется с поддержкой извлечения пользователей с помощью Eloquent и построителя запросов к базе данных. Однако вы можете определить дополнительных поставщиков, если это необходимо для вашего приложения.
# remember_token столбец из 100 символов. Этот столбец будет использоваться для хранения токена для пользователей, выбравших опцию «запомнить меня» при входе в ваше приложение
# Файл cookie, выданный браузеру, содержит идентификатор сеанса, чтобы последующие запросы к приложению могли связать пользователя с правильным сеансом.
# Когда удаленной службе необходимо пройти аутентификацию для доступа к API, файлы cookie обычно не используются для аутентификации, поскольку веб-браузер отсутствует. Вместо этого удаленная служба отправляет токен API в API при каждом запросе. Приложение может проверить входящий токен по таблице действительных токенов API и «аутентифицировать» запрос как выполненный пользователем, связанным с этим токеном API.

# Службы аутентификации API Laravel
# aravel предоставляет два дополнительных пакета, которые помогут вам в управлении токенами API и аутентификации запросов, сделанных с помощью токенов API: Passport и Sanctum .
# -------------------------------------------------------------------

if (Auth::check()) { }
$user = Auth::user();
$id = Auth::id();

Route::get('/flights', function () { })->middleware('auth'); // Only authenticated users may access this route...
Route::get('/profile', function () { })->middleware('auth.basic');

if (Auth::guard('admin')->attempt($credentials)) {
if (Auth::attempt($credentials)) {
    $request->session()->regenerate();
    return redirect()->intended('dashboard'); // перенаправит пользователя на URL-адрес, к которому он пытался получить доступ
}

Auth::login($user, $remember = true);
Auth::guard('admin')->login($user);
Auth::loginUsingId(1);
Auth::loginUsingId(1, $remember = true);
if (Auth::once($credentials)) {

Auth::logout();
Auth::logoutOtherDevices($currentPassword);
$request->session()->invalidate();
$request->session()->regenerateToken();

# -------------------------------------------------------------------
# | 29 | Authorization (Авторизация)
# Laravel предоставляет два основных способа авторизации действий: гейты и политики
# Думайте о шлюзах и политиках как о маршрутах и ​​контроллерах. Шлюзы обеспечивают простой подход к авторизации на основе замыкания, в то время как политики, такие как контроллеры, группируют логику вокруг конкретной модели или ресурса.
# Шлюзы — это просто замыкания, которые определяют, авторизован ли пользователь для выполнения данного действия.
# -------------------------------------------------------------------

use App\Policies\PostPolicy;
use Illuminate\Support\Facades\Gate;

/**
 * Register any authentication / authorization services.
 *
 * @return void
 */
public function boot()
{
    $this->registerPolicies();

    Gate::define('update-post', function (User $user, Post $post) { return $user->id === $post->user_id; });
    Gate::define('update-post', [PostPolicy::class, 'update']);
}

<?php
namespace App\Http\Controllers;
class PostController extends Controller
{
    public function update(Request $request, Post $post)
    {
        if (Gate::forUser($user)->allows('update-post', $post)) {
        if (Gate::forUser($user)->denies('update-post', $post)) {
        if (Gate::any(['update-post', 'delete-post'], $post)) {
        if (! Gate::allows('update-post', $post)) {
            abort(403);
        }

        // Update the post...
    }
}

# -------------------------------------------------------------------
# | 31 | Database: Getting Started
# | 32 | Database: Query Builder
# | 33 | Database: Migrations
# $ php artisan db mysql
# $ php artisan db:show
# $ php artisan db:table users // Обзор таблицы
# -------------------------------------------------------------------

// Если вы хотите, чтобы привязка модели всегда использовала столбец базы данных,
// отличный от idпри извлечении данного класса модели вы можете переопределить getRouteKeyNameметод на модели Eloquent:

public function getRouteKeyName() { return 'slug'; // return $this->slug; } // getRouteKeyName метод на модели Eloquent:

// Кроме того, вы можете переопределить resolveRouteBindingна вашей модели Eloquent. Этот метод получит значение сегмента URI и должен вернуть экземпляр класса, который следует внедрить в маршрут:
public function resolveRouteBinding($value, $field = null) { return $this->where('name', $value)->firstOrFail(); }

// Если маршрут использует неявную область привязки , resolveChildRouteBindingметод будет использоваться для разрешения дочерней привязки родительской модели:
public function resolveChildRouteBinding($childType, $value, $field) { return parent::resolveChildRouteBinding($childType, $value, $field); }

use Illuminate\Support\Facades\DB;
$users = DB::select('select * from users where active = ?', [1]);
$results = DB::select('select * from users where id = :id', ['id' => 1]);
$burgers = DB::scalar("select count(case when food = 'burger' then 1 end) as burgers from menu");

DB::insert('insert into users (id, name) values (?, ?)', [1, 'Marc']);
$affected = DB::update('update users set votes = 100 where name = ?', ['Anita']);
$deleted = DB::delete('delete from users');
DB::statement('drop table users');


DB::transaction(function () {
    DB::update('update users set votes = 1');
    DB::delete('delete from posts');
});

DB::transaction(function () {
    DB::update('update users set votes = 1');

    DB::delete('delete from posts');
}, 5); // сколько раз транзакция должна быть повторена при возникновении взаимоблокировки

// Ручное использование транзакций
DB::beginTransaction();
DB::rollBack();
DB::commit();

$users = DB::table('users')->get();
$user = DB::table('users')->where('name', 'John')->first();
$email = DB::table('users')->where('name', 'John')->value('email');
$user = DB::table('users')->find(3);
$titles = DB::table('users')->pluck('title', 'name'); // Получение списка значений столбца
$users = DB::table('users')->count();
$price = DB::table('orders')->max('price');
$price = DB::table('orders')->where('finalized', 1)->avg('price');
if (DB::table('orders')->where('finalized', 1)->exists()) { }
if (DB::table('orders')->where('finalized', 1)->doesntExist()) { }
$users = DB::table('users')->select('name', 'email as user_email')->get();
$users = DB::table('users')->distinct()->get();
$query = DB::table('users')->select('name');
$users = $query->addSelect('age')->get();
$users = DB::table('users')
                ->when($sortByVotes, function ($query, $sortByVotes) {
                    $query->orderBy('votes');
                }, function ($query) {
                    $query->orderBy('name');
                })
            ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
             ->select(DB::raw('count(*) as user_count, status'))
             ->selectRaw('price * ? as price_with_tax', [1.0825])
             ->whereRaw('price > IF(state = "TX", ?, 100)', [200])
             ->where('status', '<>', 1)
             ->join('contacts', 'users.id', '=', 'contacts.user_id')
             ->join('orders', 'users.id', '=', 'orders.user_id')
             ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
             ->rightJoin('posts', 'users.id', '=', 'posts.user_id')
            ->join('contacts', function ($join) {
                $join->on('users.id', '=', 'contacts.user_id')->orOn(/* ... */);
            })
        ->join('contacts', function ($join) {
            $join->on('users.id', '=', 'contacts.user_id')
                 ->where('contacts.user_id', '>', 5);
        })
                             ->joinSub($latestPosts, 'latest_posts', function ($join) {
                                 $join->on('users.id', '=', 'latest_posts.user_id');
                             })->get();
             ->havingRaw('SUM(price) > ?', [2500])
             ->orderByRaw('updated_at - created_at DESC')
             ->groupByRaw('city, state')
             ->groupBy('status')

             ->where('votes', 100)
             ->where('votes', '=', 100)
             ->where('age', '>', 35)
             ->orWhere('name', 'John')
             ->where([
                 ['status', '=', '1'],
                 ['subscribed', '<>', '1'],
             ])
                         ->orWhere(function($query) {
                             $query->where('name', 'Abigail')
                                   ->where('votes', '>', 50);
                         })
                                         ->whereNot(function ($query) {
                                             $query->where('clearance', true)
                                                   ->orWhere('price', '<', 10);
                                         })
             ->where('name', 'like', 'T%')
             ->whereNull('last_name')
             ->whereNull('updated_at')
             ->whereNotNull('updated_at')
             ->whereBetween('votes', [1, 100])
             ->whereNotBetween('votes', [1, 100])
             ->whereIn('id', [1, 2, 3])
             ->whereNotIn('id', [1, 2, 3])

             ->whereDate('created_at', '2016-12-31')
             ->whereMonth('created_at', '12')
             ->whereDay('created_at', '31')
             ->whereYear('created_at', '2016')
             ->whereTime('created_at', '=', '11:20:45')

             ->whereColumn('first_name', 'last_name')
             ->whereColumn('updated_at', '>', 'created_at')
                             ->whereColumn([
                                 ['first_name', '=', 'last_name'],
                                 ['updated_at', '>', 'created_at'],
                             ])

                        ->whereExists(function ($query) {
                            $query->select(DB::raw(1))
                                  ->from('orders')
                                  ->whereColumn('orders.user_id', 'users.id');
                        })

             ->where('preferences->dining->meal', 'salad') // JSON
             ->whereJsonContains('options->languages', 'en') // JSON
             ->whereJsonContains('options->languages', ['en', 'de'])
             ->whereJsonLength('options->languages', 0)
             ->whereJsonLength('options->languages', '>', 1)

             ->whereFullText('bio', 'web developer')
             ->inRandomOrder()
             ->orderBy('name', 'desc')
             ->orderBy('email', 'asc')
             ->groupBy('first_name', 'status')
             ->having('account_id', '>', 100)
             ->havingBetween('number_of_orders', [5, 15])
             ->union($first)

             ->skip(10)->take(5)
             ->offset(10)->limit(5) // тоже самое

                ->when($sortByVotes, function ($query, $sortByVotes) {
                    $query->orderBy('votes');
                }, function ($query) {
                    $query->orderBy('name');
                })
             ->get();


DB::table('users')->insert([
    ['email' => 'picard@example.com', 'votes' => 0],
    ['email' => 'janeway@example.com', 'votes' => 0],
]);

$id = DB::table('users')->insertGetId(
    ['email' => 'john@example.com', 'votes' => 0]
);


$incomes = Income::where('amount', '<', function ($query) {
    $query->selectRaw('avg(i.amount)')->from('incomes as i');
})->get();

$affected = DB::table('users')
              ->where('id', 1)
              ->update(['options->enabled' => true])
              ->update(['votes' => 1])
              ->updateOrInsert(
                ['email' => 'john@example.com', 'name' => 'John'],
                ['votes' => '2']
              );

DB::table('users')->increment('votes', 1, ['name' => 'John']);
DB::table('users')->increment('votes');
DB::table('users')->increment('votes', 5);
DB::table('users')->decrement('votes');
DB::table('users')->decrement('votes', 5);

$deleted = DB::table('users')->delete();
$deleted = DB::table('users')->where('votes', '>', 100)->delete();
DB::table('users')->truncate();

// Пессимистическая блокировка
DB::table('users')
        ->where('votes', '>', 100)
        ->sharedLock() // Общая блокировка предотвращает изменение выбранных строк до тех пор, пока ваша транзакция не будет зафиксирована:
        ->lockForUpdate() // предотвращает изменение выбранных записей или их выбор с помощью другой общей блокировки
        ->get();

// Отладка
DB::table('users')->where('votes', '>', 100)->dd();
DB::table('users')->where('votes', '>', 100)->dump();

// Простая нумерация страниц
$users = DB::table('users')->paginate(15)
$users = DB::table('users')->simplePaginate(15);
$users = User::paginate(15);
$users->withPath('/admin/users');
$users->appends(['sort' => 'votes']);

<div class="container">
    @foreach ($users as $user)
        {{ $user->name }}
    @endforeach
</div>

{{ $users->links() }}
{{ $users->onEachSide(5)->links() }}

// Миграции подобны контролю версий для вашей базы данных, позволяя вашей команде определять и совместно использовать определение схемы базы данных приложения
// $php artisan migrate
// $php artisan migrate:status
// $php artisan migrate --pretend // увидеть операторы SQL, которые будут выполняться миграциями без их фактического запуска
// $php artisan migrate:rollback

<?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
return new class extends Migration
{
    protected $connection = 'pgsql';

    public function up()
    {
        Schema::create('flights', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('airline');
            $table->timestamps();
        });
    }

    public function down()
    {
        Schema::drop('flights');
    }
};

# -------------------------------------------------------------------
# | 34 | Eloquent: Getting Started
# | 35 | Eloquent: Relationships
# $ php artisan model:show Flight
# -------------------------------------------------------------------

// По соглашению, имя класса во множественном числе будет использоваться в качестве имени таблицы
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Flight extends Model
{
    use SoftDeletes; // deleted_at // Мягкое удаление
    protected $fillable = ['name']; // какие атрибуты могут быть массово назначены
    protected $fillable = [
        'options->enabled', // JSON
    ];

    // Разрешение массового назначения
    protected $guarded = [];

    protected $table = 'my_flights';
    protected $primaryKey = 'flight_id';
    public $incrementing = false;
    protected $keyType = 'string'; // Если первичный ключ вашей модели не является целым числом
    public $timestamps = false; // created_atа также updated_at столбцы
    protected $dateFormat = 'U';
    const CREATED_AT = 'creation_date';
    const UPDATED_AT = 'updated_date'; // Model::withoutTimestamps(fn () => $post->incrememt(['reads']));
    protected $connection = 'sqlite';

        // Значения атрибутов по умолчанию
        protected $attributes = [
            'delayed' => false,
        ];

    // Вместо использования автоматически увеличивающихся целых чисел в качестве первичных ключей вашей модели Eloquent вы можете вместо этого использовать UUID.
    // UUID — это универсальные уникальные буквенно-цифровые идентификаторы длиной 36 символов.
    // ULID аналогичны UUID; однако их длина составляет всего 26 символов.
    use \Illuminate\Database\Eloquent\Concerns\HasUuids;
    $article = Article::create(['title' => 'Traveling to Europe']);
    $article->id; // "8f8e8478-9035-4d23-b9a7-62f4d2612ce5"
    $article->id; // "01gd4d3tgrrfqeda94gdbtdk5c"

    // Анонимные глобальные ограничения
    User::withoutGlobalScope(AncientScope::class)->get();
    User::withoutGlobalScope('ancient')->get();
    User::withoutGlobalScopes()->get();
    protected static function booted()
    {
        static::addGlobalScope('ancient', function (Builder $builder) {
            $builder->where('created_at', '<', now()->subYears(2000));
        });
    }

    // Локальные ограничения
    $users = User::ofType('admin')->get();
    public function scopeOfType($query, $type)
    {
        return $query->where('type', $type);
    }
}

foreach (Flight::all() as $flight) {
    echo $flight->name;
}

$flight = Flight::where('number', 'FR 900')->first();
$flight->number = 'FR 456';
$flight->refresh();
$flight->number; // "FR 900"

$flights = Flight::where('destination', 'Paris')->get();
$flights = $flights->reject(function ($flight) {
    return $flight->cancelled;
});

// Разделение результатов
Flight::chunk(200, function ($flights) {
    foreach ($flights as $flight) {
        //
    }
});

$flight = Flight::find(1);
$flight = Flight::where('active', 1)->first();
$flight = Flight::firstWhere('active', 1);
$flight = Flight::findOr(1, function () {});
$flight = Flight::where('legs', '>', 3)->firstOr(function () {});
$flight = Flight::findOrFail(1); // ModelNotFoundException
$flight = Flight::where('legs', '>', 3)->firstOrFail();

// все модели Eloquent по умолчанию защищены от уязвимостей массового назначения.
// нужно будет указать либо fillableили же guardedсвойство в вашем классе модели
$flight = Flight::create([
    'name' => 'London to Paris',
]);

$flight = Flight::firstOrCreate(
    ['name' => 'London to Paris'],
    ['delayed' => 1, 'arrival_time' => '11:30']
);

$flight = Flight::firstOrNew(
    ['name' => 'Tokyo to Sydney'],
    ['delayed' => 1, 'arrival_time' => '11:30']
);

$flight = new Flight;
$flight->name = $request->name;
$flight->save();

$count = Flight::where('active', 1)->count();
$max = Flight::where('active', 1)->max('price');

$flight = Flight::find(1);
$flight->name = 'Paris to London';
$flight->save();

// При выпуске массового обновления через Eloquent saving, saved, updating, а также updatedсобытия модели не будут запускаться для обновленных моделей.
Flight::where('active', 1)
      ->where('destination', 'San Diego')
      ->update(['delayed' => 1]);

$flight = Flight::find(1);
$flight->delete();
Flight::truncate();
Flight::destroy(1);
Flight::destroy(1, 2, 3);
Flight::destroy([1, 2, 3]);
Flight::destroy(collect([1, 2, 3]));
$deleted = Flight::where('active', 0)->delete();

if ($post->is($anotherPost)) { }
if ($post->isNot($anotherPost)) { }
if ($post->author()->is($user)) { }

$comments = Post::find(1)->comments;
foreach ($comments as $comment) { }
$comment = Post::find(1)->comments()->where('title', 'foo')->first();
$comment = Comment::find(1);
return $comment->post->title;

// Один к одному
return $this->hasOne(Phone::class);
return $this->belongsTo(User::class);

// Один ко многим
return $this->hasMany(Comment::class);
return $this->belongsTo(Post::class);

// один из многих

# -------------------------------------------------------------------
# Команды
# -------------------------------------------------------------------

$ php artisan about --only=environment
$ php artisan list make // доступные команды
$ php artisan storage:link  // создать символическую ссылку  на папку public/storage
$ php artisan up // выключить режим обслуживания
$ php artisan down // включить режим обслуживания (resources/views/errors/503.blade.php), пока ваше приложение находится в режиме обслуживания, задания в очереди обрабатываться не будут.

$ php artisan test
$ php artisan test --coverage // тестовое покрытие с помощью Artisan

// Очистка кэша (оптимизация)
$ composer install --optimize-autoloader --no-dev // оптимизация на проде
$ php artisan route:cache // во время развертывания вашего проекта.
$ php artisan config:cache
$ php artisan view:clear
$ php artisan view:cache

# -------------------------------------------------------------------
# Классы, хелперы, фасады
# -------------------------------------------------------------------

$value = env('APP_DEBUG', false), // APP_DEBUG
$value = config('app.timezone', 'Asia/Seoul');

use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Route;
use Illuminate\Support\Facades\Response;

use Psr\Container\ContainerInterface; // ContainerInterface $container // $service = $container->get(Transistor::class);
if (\Illuminate\Support\Facades\App::environment('local')) {}

if ($request->route()->named('profile')) { }
$url = route('profile');
$url = route('profile', ['id' => 1, 'photos' => 'yes']); // user/1/profile?photos=yes

return redirect()->route('profile'); // Generating Redirects...
return to_route('profile');

# -------------------------------------------------------------------
# Разное
# -------------------------------------------------------------------

$ touch database/database.sqlite DB_CONNECTION=sqlite

# -------------------------------------------------------------------
# Отладка
# -------------------------------------------------------------------

// Получить текущий маршрут во view
$currentRouteAction = \Illuminate\Support\Facades\Route::currentRouteAction();

dd($var1, $var2, $var3);
dump();

\Log::useDailyFiles(storage_path().'/logs/name-of-log.log');
\Log::info('msg');

# -------------------------------------------------------------------
# Новое в 9
# -------------------------------------------------------------------

// Улучшенные Eloquent Accessors/Mutators
use App\Support\Address;
use Illuminate\Database\Eloquent\Casts\Attribute;
public function address(): Attribute
{
    return new Attribute(
        get: fn ($value, $attributes) => new Address(
            $attributes['address_line_one'],
            $attributes['address_line_two'],
        ),
        set: fn (Address $value) => [
            'address_line_one' => $value->lineOne,
            'address_line_two' => $value->lineTwo,
        ],
    );
}

--

// Enum Eloquent Attribute Casting
protected $casts = [
    'status' => \App\Enums\ServerStatus\ServerStatus::class,
];
if ($server->status == ServerStatus::provisioned) {
    $server->status = ServerStatus::ready;
    $server->save();
}

--

// Неявные привязки маршрутов с перечислениями
enum Category: string
{
    case Fruits = 'fruits';
    case People = 'people';
}

Route::get('/categories/{category}', function (Category $category) {
    return $category->value;
});

// Принудительное определение области привязки маршрута
Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {
    return $post;
});

--

// Новые директивы @checked, @disabledи @selectedBlade могут конфликтовать с одноименными событиями Vue.
// Вы можете использовать @@, чтобы избежать директив и избежать этого конфликта: @@selected.
@checked(old('active', $user->active)) />
@selected(old('version') == $version)>

--

// Полнотекстовые указатели / операторы Where
$table->text('bio')->fullText();
$table->text('bio')->fullText();
$users = DB::table('users')->whereFullText('bio', 'web developer')->get();

# -------------------------------------------------------------------
# ???
# -------------------------------------------------------------------

1)
https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#the_http_response_headers
CORS OPTIONS HTTP requests with values that you configure.
All CORS settings may be configured in your application's config/cors.php

// Поверхностно просмотрел
// https://laravel.com/docs/9.x/broadcasting (не изучил)
// https://laravel.com/docs/9.x/validation
// https://laravel.com/docs/9.x/collections
// https://laravel.com/docs/9.x/collections#lazy-collection-introduction
// https://laravel.com/docs/9.x/helpers
// https://laravel.com/docs/9.x/http-client
// https://laravel.com/docs/9.x/localization
// https://laravel.com/docs/9.x/notifications
// https://laravel.com/docs/9.x/rate-limiting (не изучил)
// https://laravel.com/docs/9.x/queues
// https://laravel.com/docs/9.x/authorization